// Code generated by protoc-gen-gogo.
// source: verifierlocal.proto
// DO NOT EDIT!

package proto

// discarding unused import gogoproto "gogoproto"

import fmt "fmt"
import bytes "bytes"

import strings "strings"
import github_com_andres_erbsen_protobuf_proto "github.com/andres-erbsen/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

// Verifier contains the persistent internal state of a verifier.
// Additional on-disk state is described in verifier/table.go.
type VerifierState struct {
	NextIndex           uint64               `protobuf:"varint,1,opt,name=next_index,proto3" json:"next_index,omitempty"`
	NextEpoch           uint64               `protobuf:"varint,2,opt,name=next_epoch,proto3" json:"next_epoch,omitempty"`
	PreviousSummaryHash []byte               `protobuf:"bytes,3,opt,name=previous_summary_hash,proto3" json:"previous_summary_hash,omitempty"`
	LatestTreeSnapshot  uint64               `protobuf:"varint,4,opt,name=latest_tree_snapshot,proto3" json:"latest_tree_snapshot,omitempty"`
	KeyserverAuth       *AuthorizationPolicy `protobuf:"bytes,5,opt,name=keyserver_auth" json:"keyserver_auth,omitempty"`
}

func (m *VerifierState) Reset()      { *m = VerifierState{} }
func (*VerifierState) ProtoMessage() {}

func (m *VerifierState) GetKeyserverAuth() *AuthorizationPolicy {
	if m != nil {
		return m.KeyserverAuth
	}
	return nil
}

func (this *VerifierState) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*VerifierState)
	if !ok {
		return fmt.Errorf("that is not of type *VerifierState")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *VerifierState but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *VerifierStatebut is not nil && this == nil")
	}
	if this.NextIndex != that1.NextIndex {
		return fmt.Errorf("NextIndex this(%v) Not Equal that(%v)", this.NextIndex, that1.NextIndex)
	}
	if this.NextEpoch != that1.NextEpoch {
		return fmt.Errorf("NextEpoch this(%v) Not Equal that(%v)", this.NextEpoch, that1.NextEpoch)
	}
	if !bytes.Equal(this.PreviousSummaryHash, that1.PreviousSummaryHash) {
		return fmt.Errorf("PreviousSummaryHash this(%v) Not Equal that(%v)", this.PreviousSummaryHash, that1.PreviousSummaryHash)
	}
	if this.LatestTreeSnapshot != that1.LatestTreeSnapshot {
		return fmt.Errorf("LatestTreeSnapshot this(%v) Not Equal that(%v)", this.LatestTreeSnapshot, that1.LatestTreeSnapshot)
	}
	if !this.KeyserverAuth.Equal(that1.KeyserverAuth) {
		return fmt.Errorf("KeyserverAuth this(%v) Not Equal that(%v)", this.KeyserverAuth, that1.KeyserverAuth)
	}
	return nil
}
func (this *VerifierState) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*VerifierState)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.NextIndex != that1.NextIndex {
		return false
	}
	if this.NextEpoch != that1.NextEpoch {
		return false
	}
	if !bytes.Equal(this.PreviousSummaryHash, that1.PreviousSummaryHash) {
		return false
	}
	if this.LatestTreeSnapshot != that1.LatestTreeSnapshot {
		return false
	}
	if !this.KeyserverAuth.Equal(that1.KeyserverAuth) {
		return false
	}
	return true
}
func (this *VerifierState) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.VerifierState{` +
		`NextIndex:` + fmt.Sprintf("%#v", this.NextIndex),
		`NextEpoch:` + fmt.Sprintf("%#v", this.NextEpoch),
		`PreviousSummaryHash:` + fmt.Sprintf("%#v", this.PreviousSummaryHash),
		`LatestTreeSnapshot:` + fmt.Sprintf("%#v", this.LatestTreeSnapshot),
		`KeyserverAuth:` + fmt.Sprintf("%#v", this.KeyserverAuth) + `}`}, ", ")
	return s
}
func valueToGoStringVerifierlocal(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringVerifierlocal(e map[int32]github_com_andres_erbsen_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func NewPopulatedVerifierState(r randyVerifierlocal, easy bool) *VerifierState {
	this := &VerifierState{}
	this.NextIndex = uint64(uint64(r.Uint32()))
	this.NextEpoch = uint64(uint64(r.Uint32()))
	v1 := r.Intn(100)
	this.PreviousSummaryHash = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.PreviousSummaryHash[i] = byte(r.Intn(256))
	}
	this.LatestTreeSnapshot = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		this.KeyserverAuth = NewPopulatedAuthorizationPolicy(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyVerifierlocal interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneVerifierlocal(r randyVerifierlocal) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringVerifierlocal(r randyVerifierlocal) string {
	v2 := r.Intn(100)
	tmps := make([]rune, v2)
	for i := 0; i < v2; i++ {
		tmps[i] = randUTF8RuneVerifierlocal(r)
	}
	return string(tmps)
}
func randUnrecognizedVerifierlocal(r randyVerifierlocal, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldVerifierlocal(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldVerifierlocal(data []byte, r randyVerifierlocal, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateVerifierlocal(data, uint64(key))
		v3 := r.Int63()
		if r.Intn(2) == 0 {
			v3 *= -1
		}
		data = encodeVarintPopulateVerifierlocal(data, uint64(v3))
	case 1:
		data = encodeVarintPopulateVerifierlocal(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateVerifierlocal(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateVerifierlocal(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateVerifierlocal(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateVerifierlocal(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (this *VerifierState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VerifierState{`,
		`NextIndex:` + fmt.Sprintf("%v", this.NextIndex) + `,`,
		`NextEpoch:` + fmt.Sprintf("%v", this.NextEpoch) + `,`,
		`PreviousSummaryHash:` + fmt.Sprintf("%v", this.PreviousSummaryHash) + `,`,
		`LatestTreeSnapshot:` + fmt.Sprintf("%v", this.LatestTreeSnapshot) + `,`,
		`KeyserverAuth:` + strings.Replace(fmt.Sprintf("%v", this.KeyserverAuth), "AuthorizationPolicy", "AuthorizationPolicy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringVerifierlocal(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
