// Code generated by protoc-gen-gogo.
// source: tlsconfig.proto
// DO NOT EDIT!

package proto

import proto1 "github.com/maditya/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/maditya/protobuf/gogoproto"

import strconv "strconv"

import bytes "bytes"

import strings "strings"
import github_com_maditya_protobuf_proto "github.com/maditya/protobuf/proto"
import sort "sort"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TLSVersion int32

const (
	TLSVersion_UNSPECIFIED TLSVersion = 0
	VERSION_SSL30          TLSVersion = 768
	VERSION_TLS10          TLSVersion = 769
	VERSION_TLS11          TLSVersion = 770
	VERSION_TLS12          TLSVersion = 771
)

var TLSVersion_name = map[int32]string{
	0:   "TLSVersion_UNSPECIFIED",
	768: "VERSION_SSL30",
	769: "VERSION_TLS10",
	770: "VERSION_TLS11",
	771: "VERSION_TLS12",
}
var TLSVersion_value = map[string]int32{
	"TLSVersion_UNSPECIFIED": 0,
	"VERSION_SSL30":          768,
	"VERSION_TLS10":          769,
	"VERSION_TLS11":          770,
	"VERSION_TLS12":          771,
}

func (TLSVersion) EnumDescriptor() ([]byte, []int) { return fileDescriptorTlsconfig, []int{0} }

type ClientAuthType int32

const (
	NO_CLIENT_CERT                 ClientAuthType = 0
	REQUEST_CLIENT_CERT            ClientAuthType = 1
	REQUIRE_ANY_CLIENT_CERT        ClientAuthType = 2
	VERIFY_CLIENT_CERT_IF_GIVEN    ClientAuthType = 3
	REQUIRE_AND_VERIFY_CLIENT_CERT ClientAuthType = 4
)

var ClientAuthType_name = map[int32]string{
	0: "NO_CLIENT_CERT",
	1: "REQUEST_CLIENT_CERT",
	2: "REQUIRE_ANY_CLIENT_CERT",
	3: "VERIFY_CLIENT_CERT_IF_GIVEN",
	4: "REQUIRE_AND_VERIFY_CLIENT_CERT",
}
var ClientAuthType_value = map[string]int32{
	"NO_CLIENT_CERT":                 0,
	"REQUEST_CLIENT_CERT":            1,
	"REQUIRE_ANY_CLIENT_CERT":        2,
	"VERIFY_CLIENT_CERT_IF_GIVEN":    3,
	"REQUIRE_AND_VERIFY_CLIENT_CERT": 4,
}

func (ClientAuthType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTlsconfig, []int{1} }

type CipherSuite int32

const (
	CipherSuite_UNSPECIFIED                 CipherSuite = 0
	TLS_RSA_WITH_RC4_128_SHA                CipherSuite = 5
	TLS_RSA_WITH_3DES_EDE_CBC_SHA           CipherSuite = 10
	TLS_RSA_WITH_AES_128_CBC_SHA            CipherSuite = 47
	TLS_RSA_WITH_AES_256_CBC_SHA            CipherSuite = 53
	TLS_ECDHE_ECDSA_WITH_RC4_128_SHA        CipherSuite = 49159
	TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    CipherSuite = 49161
	TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    CipherSuite = 49162
	TLS_ECDHE_RSA_WITH_RC4_128_SHA          CipherSuite = 49169
	TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     CipherSuite = 49170
	TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      CipherSuite = 49171
	TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      CipherSuite = 49172
	TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   CipherSuite = 49199
	TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 CipherSuite = 49195
	TLS_FALLBACK_SCSV                       CipherSuite = 22016
)

var CipherSuite_name = map[int32]string{
	0:     "CipherSuite_UNSPECIFIED",
	5:     "TLS_RSA_WITH_RC4_128_SHA",
	10:    "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
	47:    "TLS_RSA_WITH_AES_128_CBC_SHA",
	53:    "TLS_RSA_WITH_AES_256_CBC_SHA",
	49159: "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
	49161: "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
	49162: "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
	49169: "TLS_ECDHE_RSA_WITH_RC4_128_SHA",
	49170: "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
	49171: "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
	49172: "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
	49199: "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
	49195: "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
	22016: "TLS_FALLBACK_SCSV",
}
var CipherSuite_value = map[string]int32{
	"CipherSuite_UNSPECIFIED":                 0,
	"TLS_RSA_WITH_RC4_128_SHA":                5,
	"TLS_RSA_WITH_3DES_EDE_CBC_SHA":           10,
	"TLS_RSA_WITH_AES_128_CBC_SHA":            47,
	"TLS_RSA_WITH_AES_256_CBC_SHA":            53,
	"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA":        49159,
	"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA":    49161,
	"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA":    49162,
	"TLS_ECDHE_RSA_WITH_RC4_128_SHA":          49169,
	"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA":     49170,
	"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA":      49171,
	"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA":      49172,
	"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256":   49199,
	"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256": 49195,
	"TLS_FALLBACK_SCSV":                       22016,
}

func (CipherSuite) EnumDescriptor() ([]byte, []int) { return fileDescriptorTlsconfig, []int{2} }

type CurveID int32

const (
	CurveID_UNSPECIFIED CurveID = 0
	P256                CurveID = 23
	P384                CurveID = 24
	P521                CurveID = 25
)

var CurveID_name = map[int32]string{
	0:  "CurveID_UNSPECIFIED",
	23: "P256",
	24: "P384",
	25: "P521",
}
var CurveID_value = map[string]int32{
	"CurveID_UNSPECIFIED": 0,
	"P256":                23,
	"P384":                24,
	"P521":                25,
}

func (CurveID) EnumDescriptor() ([]byte, []int) { return fileDescriptorTlsconfig, []int{3} }

// TLSConfig structure is used to configure a TLS client or server.
type TLSConfig struct {
	// Certificates contains one or more certificate chains
	// to present to the other side of the connection.
	// Server configurations must include at least one certificate.
	Certificates []*CertificateAndKeyID `protobuf:"bytes,1,rep,name=certificates" json:"certificates,omitempty"`
	// RootCAs defines the set of root certificate authorities
	// that clients use when verifying server certificates.
	// If RootCAs is nil, TLS uses the host's root CA set.
	// The certificates are expected in DER format.
	RootCAs [][]byte `protobuf:"bytes,3,rep,name=root_cas,json=rootCas" json:"root_cas,omitempty"`
	// NextProtos is a list of supported, application level protocols.
	NextProtos []string `protobuf:"bytes,4,rep,name=next_protos,json=nextProtos" json:"next_protos,omitempty"`
	// ServerName is used to verify the hostname on the returned
	// certificates. It is also included in the client's handshake to support
	// virtual hosting.
	ServerName string `protobuf:"bytes,5,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
	// ClientAuth determines the server's policy for
	// TLS Client Authentication. The default is NoClientCert.
	ClientAuth ClientAuthType `protobuf:"varint,6,opt,name=client_auth,json=clientAuth,proto3,enum=proto.ClientAuthType" json:"client_auth,omitempty"`
	// ClientCAs defines the set of root certificate authorities that servers
	// use if required to verify a client certificate by the policy in
	// ClientAuth. The certificates are expected in DER format.
	ClientCAs [][]byte `protobuf:"bytes,7,rep,name=client_cas,json=clientCas" json:"client_cas,omitempty"`
	// CipherSuites is a list of supported cipher suites. If CipherSuites
	// is nil, TLS uses a list of suites supported by the implementation.
	CipherSuites []CipherSuite `protobuf:"varint,8,rep,name=cipher_suites,json=cipherSuites,enum=proto.CipherSuite" json:"cipher_suites,omitempty"`
	// PreferServerCipherSuites controls whether the server selects the
	// client's most preferred ciphersuite, or the server's most preferred
	// ciphersuite. If true then the server's preference, as expressed in
	// the order of elements in CipherSuites, is used.
	PreferServerCipherSuites bool `protobuf:"varint,9,opt,name=prefer_server_cipher_suites,json=preferServerCipherSuites,proto3" json:"prefer_server_cipher_suites,omitempty"`
	// SessionTicketsEnabled may be set to true to enable session ticket
	// (resumption) support. Enabling session tickets limits forward secrecy to
	// until after the lifetime of the session ticket key (which, by default,
	// lives as long as the server process).
	SessionTicketsEnabled bool `protobuf:"varint,10,opt,name=session_tickets_enabled,json=sessionTicketsEnabled,proto3" json:"session_tickets_enabled,omitempty"`
	// SessionTicketKey (32 bytes) is used by TLS servers to provide session
	// resumption. See RFC 5077. If zero, it will be filled with random data
	// before the first server handshake.
	//
	// If multiple servers are terminating connections for the same host
	// they should all have the same SessionTicketKey. If the
	// SessionTicketKey leaks, previously recorded and future TLS
	// connections using that key are compromised.
	SessionTicketKeyID string `protobuf:"bytes,11,opt,name=session_ticket_key_id,json=sessionTicketKeyId,proto3" json:"session_ticket_key_id,omitempty"`
	// MinVersion contains the minimum SSL/TLS version that is acceptable.
	// If zero, then SSLv3 is taken as the minimum.
	MinVersion TLSVersion `protobuf:"varint,12,opt,name=min_version,json=minVersion,proto3,enum=proto.TLSVersion" json:"min_version,omitempty"`
	// MaxVersion contains the maximum SSL/TLS version that is acceptable.
	// If zero, then the maximum version supported by this package is used,
	// which is currently TLS 1.2.
	MaxVersion TLSVersion `protobuf:"varint,13,opt,name=max_version,json=maxVersion,proto3,enum=proto.TLSVersion" json:"max_version,omitempty"`
	// CurvePreferences contains the elliptic curves that will be used in
	// an ECDHE handshake, in preference order. If empty, the default will
	// be used.
	CurvePreferences []CurveID `protobuf:"varint,14,rep,name=curve_preferences,json=curvePreferences,enum=proto.CurveID" json:"curve_preferences,omitempty"`
}

func (m *TLSConfig) Reset()                    { *m = TLSConfig{} }
func (*TLSConfig) ProtoMessage()               {}
func (*TLSConfig) Descriptor() ([]byte, []int) { return fileDescriptorTlsconfig, []int{0} }

func (m *TLSConfig) GetCertificates() []*CertificateAndKeyID {
	if m != nil {
		return m.Certificates
	}
	return nil
}

type CertificateAndKeyID struct {
	// Certificate contains the public certificates in DER format, leaf first.
	Certificate [][]byte `protobuf:"bytes,1,rep,name=certificate" json:"certificate,omitempty"`
	KeyID       string   `protobuf:"bytes,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	OCSPStaple  []byte   `protobuf:"bytes,3,opt,name=OCSP_staple,json=oCSPStaple,proto3" json:"OCSP_staple,omitempty"`
}

func (m *CertificateAndKeyID) Reset()                    { *m = CertificateAndKeyID{} }
func (*CertificateAndKeyID) ProtoMessage()               {}
func (*CertificateAndKeyID) Descriptor() ([]byte, []int) { return fileDescriptorTlsconfig, []int{1} }

func init() {
	proto1.RegisterType((*TLSConfig)(nil), "proto.TLSConfig")
	proto1.RegisterType((*CertificateAndKeyID)(nil), "proto.CertificateAndKeyID")
	proto1.RegisterEnum("proto.TLSVersion", TLSVersion_name, TLSVersion_value)
	proto1.RegisterEnum("proto.ClientAuthType", ClientAuthType_name, ClientAuthType_value)
	proto1.RegisterEnum("proto.CipherSuite", CipherSuite_name, CipherSuite_value)
	proto1.RegisterEnum("proto.CurveID", CurveID_name, CurveID_value)
}
func (x TLSVersion) String() string {
	s, ok := TLSVersion_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ClientAuthType) String() string {
	s, ok := ClientAuthType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CipherSuite) String() string {
	s, ok := CipherSuite_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CurveID) String() string {
	s, ok := CurveID_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *TLSConfig) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TLSConfig)
	if !ok {
		that2, ok := that.(TLSConfig)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TLSConfig")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TLSConfig but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TLSConfig but is not nil && this == nil")
	}
	if len(this.Certificates) != len(that1.Certificates) {
		return fmt.Errorf("Certificates this(%v) Not Equal that(%v)", len(this.Certificates), len(that1.Certificates))
	}
	for i := range this.Certificates {
		if !this.Certificates[i].Equal(that1.Certificates[i]) {
			return fmt.Errorf("Certificates this[%v](%v) Not Equal that[%v](%v)", i, this.Certificates[i], i, that1.Certificates[i])
		}
	}
	if len(this.RootCAs) != len(that1.RootCAs) {
		return fmt.Errorf("RootCAs this(%v) Not Equal that(%v)", len(this.RootCAs), len(that1.RootCAs))
	}
	for i := range this.RootCAs {
		if !bytes.Equal(this.RootCAs[i], that1.RootCAs[i]) {
			return fmt.Errorf("RootCAs this[%v](%v) Not Equal that[%v](%v)", i, this.RootCAs[i], i, that1.RootCAs[i])
		}
	}
	if len(this.NextProtos) != len(that1.NextProtos) {
		return fmt.Errorf("NextProtos this(%v) Not Equal that(%v)", len(this.NextProtos), len(that1.NextProtos))
	}
	for i := range this.NextProtos {
		if this.NextProtos[i] != that1.NextProtos[i] {
			return fmt.Errorf("NextProtos this[%v](%v) Not Equal that[%v](%v)", i, this.NextProtos[i], i, that1.NextProtos[i])
		}
	}
	if this.ServerName != that1.ServerName {
		return fmt.Errorf("ServerName this(%v) Not Equal that(%v)", this.ServerName, that1.ServerName)
	}
	if this.ClientAuth != that1.ClientAuth {
		return fmt.Errorf("ClientAuth this(%v) Not Equal that(%v)", this.ClientAuth, that1.ClientAuth)
	}
	if len(this.ClientCAs) != len(that1.ClientCAs) {
		return fmt.Errorf("ClientCAs this(%v) Not Equal that(%v)", len(this.ClientCAs), len(that1.ClientCAs))
	}
	for i := range this.ClientCAs {
		if !bytes.Equal(this.ClientCAs[i], that1.ClientCAs[i]) {
			return fmt.Errorf("ClientCAs this[%v](%v) Not Equal that[%v](%v)", i, this.ClientCAs[i], i, that1.ClientCAs[i])
		}
	}
	if len(this.CipherSuites) != len(that1.CipherSuites) {
		return fmt.Errorf("CipherSuites this(%v) Not Equal that(%v)", len(this.CipherSuites), len(that1.CipherSuites))
	}
	for i := range this.CipherSuites {
		if this.CipherSuites[i] != that1.CipherSuites[i] {
			return fmt.Errorf("CipherSuites this[%v](%v) Not Equal that[%v](%v)", i, this.CipherSuites[i], i, that1.CipherSuites[i])
		}
	}
	if this.PreferServerCipherSuites != that1.PreferServerCipherSuites {
		return fmt.Errorf("PreferServerCipherSuites this(%v) Not Equal that(%v)", this.PreferServerCipherSuites, that1.PreferServerCipherSuites)
	}
	if this.SessionTicketsEnabled != that1.SessionTicketsEnabled {
		return fmt.Errorf("SessionTicketsEnabled this(%v) Not Equal that(%v)", this.SessionTicketsEnabled, that1.SessionTicketsEnabled)
	}
	if this.SessionTicketKeyID != that1.SessionTicketKeyID {
		return fmt.Errorf("SessionTicketKeyID this(%v) Not Equal that(%v)", this.SessionTicketKeyID, that1.SessionTicketKeyID)
	}
	if this.MinVersion != that1.MinVersion {
		return fmt.Errorf("MinVersion this(%v) Not Equal that(%v)", this.MinVersion, that1.MinVersion)
	}
	if this.MaxVersion != that1.MaxVersion {
		return fmt.Errorf("MaxVersion this(%v) Not Equal that(%v)", this.MaxVersion, that1.MaxVersion)
	}
	if len(this.CurvePreferences) != len(that1.CurvePreferences) {
		return fmt.Errorf("CurvePreferences this(%v) Not Equal that(%v)", len(this.CurvePreferences), len(that1.CurvePreferences))
	}
	for i := range this.CurvePreferences {
		if this.CurvePreferences[i] != that1.CurvePreferences[i] {
			return fmt.Errorf("CurvePreferences this[%v](%v) Not Equal that[%v](%v)", i, this.CurvePreferences[i], i, that1.CurvePreferences[i])
		}
	}
	return nil
}
func (this *TLSConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TLSConfig)
	if !ok {
		that2, ok := that.(TLSConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Certificates) != len(that1.Certificates) {
		return false
	}
	for i := range this.Certificates {
		if !this.Certificates[i].Equal(that1.Certificates[i]) {
			return false
		}
	}
	if len(this.RootCAs) != len(that1.RootCAs) {
		return false
	}
	for i := range this.RootCAs {
		if !bytes.Equal(this.RootCAs[i], that1.RootCAs[i]) {
			return false
		}
	}
	if len(this.NextProtos) != len(that1.NextProtos) {
		return false
	}
	for i := range this.NextProtos {
		if this.NextProtos[i] != that1.NextProtos[i] {
			return false
		}
	}
	if this.ServerName != that1.ServerName {
		return false
	}
	if this.ClientAuth != that1.ClientAuth {
		return false
	}
	if len(this.ClientCAs) != len(that1.ClientCAs) {
		return false
	}
	for i := range this.ClientCAs {
		if !bytes.Equal(this.ClientCAs[i], that1.ClientCAs[i]) {
			return false
		}
	}
	if len(this.CipherSuites) != len(that1.CipherSuites) {
		return false
	}
	for i := range this.CipherSuites {
		if this.CipherSuites[i] != that1.CipherSuites[i] {
			return false
		}
	}
	if this.PreferServerCipherSuites != that1.PreferServerCipherSuites {
		return false
	}
	if this.SessionTicketsEnabled != that1.SessionTicketsEnabled {
		return false
	}
	if this.SessionTicketKeyID != that1.SessionTicketKeyID {
		return false
	}
	if this.MinVersion != that1.MinVersion {
		return false
	}
	if this.MaxVersion != that1.MaxVersion {
		return false
	}
	if len(this.CurvePreferences) != len(that1.CurvePreferences) {
		return false
	}
	for i := range this.CurvePreferences {
		if this.CurvePreferences[i] != that1.CurvePreferences[i] {
			return false
		}
	}
	return true
}
func (this *CertificateAndKeyID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CertificateAndKeyID)
	if !ok {
		that2, ok := that.(CertificateAndKeyID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CertificateAndKeyID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CertificateAndKeyID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CertificateAndKeyID but is not nil && this == nil")
	}
	if len(this.Certificate) != len(that1.Certificate) {
		return fmt.Errorf("Certificate this(%v) Not Equal that(%v)", len(this.Certificate), len(that1.Certificate))
	}
	for i := range this.Certificate {
		if !bytes.Equal(this.Certificate[i], that1.Certificate[i]) {
			return fmt.Errorf("Certificate this[%v](%v) Not Equal that[%v](%v)", i, this.Certificate[i], i, that1.Certificate[i])
		}
	}
	if this.KeyID != that1.KeyID {
		return fmt.Errorf("KeyID this(%v) Not Equal that(%v)", this.KeyID, that1.KeyID)
	}
	if !bytes.Equal(this.OCSPStaple, that1.OCSPStaple) {
		return fmt.Errorf("OCSPStaple this(%v) Not Equal that(%v)", this.OCSPStaple, that1.OCSPStaple)
	}
	return nil
}
func (this *CertificateAndKeyID) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CertificateAndKeyID)
	if !ok {
		that2, ok := that.(CertificateAndKeyID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Certificate) != len(that1.Certificate) {
		return false
	}
	for i := range this.Certificate {
		if !bytes.Equal(this.Certificate[i], that1.Certificate[i]) {
			return false
		}
	}
	if this.KeyID != that1.KeyID {
		return false
	}
	if !bytes.Equal(this.OCSPStaple, that1.OCSPStaple) {
		return false
	}
	return true
}
func (this *TLSConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&proto.TLSConfig{")
	if this.Certificates != nil {
		s = append(s, "Certificates: "+fmt.Sprintf("%#v", this.Certificates)+",\n")
	}
	s = append(s, "RootCAs: "+fmt.Sprintf("%#v", this.RootCAs)+",\n")
	s = append(s, "NextProtos: "+fmt.Sprintf("%#v", this.NextProtos)+",\n")
	s = append(s, "ServerName: "+fmt.Sprintf("%#v", this.ServerName)+",\n")
	s = append(s, "ClientAuth: "+fmt.Sprintf("%#v", this.ClientAuth)+",\n")
	s = append(s, "ClientCAs: "+fmt.Sprintf("%#v", this.ClientCAs)+",\n")
	s = append(s, "CipherSuites: "+fmt.Sprintf("%#v", this.CipherSuites)+",\n")
	s = append(s, "PreferServerCipherSuites: "+fmt.Sprintf("%#v", this.PreferServerCipherSuites)+",\n")
	s = append(s, "SessionTicketsEnabled: "+fmt.Sprintf("%#v", this.SessionTicketsEnabled)+",\n")
	s = append(s, "SessionTicketKeyID: "+fmt.Sprintf("%#v", this.SessionTicketKeyID)+",\n")
	s = append(s, "MinVersion: "+fmt.Sprintf("%#v", this.MinVersion)+",\n")
	s = append(s, "MaxVersion: "+fmt.Sprintf("%#v", this.MaxVersion)+",\n")
	s = append(s, "CurvePreferences: "+fmt.Sprintf("%#v", this.CurvePreferences)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CertificateAndKeyID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto.CertificateAndKeyID{")
	s = append(s, "Certificate: "+fmt.Sprintf("%#v", this.Certificate)+",\n")
	s = append(s, "KeyID: "+fmt.Sprintf("%#v", this.KeyID)+",\n")
	s = append(s, "OCSPStaple: "+fmt.Sprintf("%#v", this.OCSPStaple)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTlsconfig(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringTlsconfig(e map[int32]github_com_maditya_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func (m *TLSConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TLSConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Certificates) > 0 {
		for _, msg := range m.Certificates {
			data[i] = 0xa
			i++
			i = encodeVarintTlsconfig(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RootCAs) > 0 {
		for _, b := range m.RootCAs {
			data[i] = 0x1a
			i++
			i = encodeVarintTlsconfig(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if len(m.NextProtos) > 0 {
		for _, s := range m.NextProtos {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ServerName) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintTlsconfig(data, i, uint64(len(m.ServerName)))
		i += copy(data[i:], m.ServerName)
	}
	if m.ClientAuth != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintTlsconfig(data, i, uint64(m.ClientAuth))
	}
	if len(m.ClientCAs) > 0 {
		for _, b := range m.ClientCAs {
			data[i] = 0x3a
			i++
			i = encodeVarintTlsconfig(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if len(m.CipherSuites) > 0 {
		for _, num := range m.CipherSuites {
			data[i] = 0x40
			i++
			i = encodeVarintTlsconfig(data, i, uint64(num))
		}
	}
	if m.PreferServerCipherSuites {
		data[i] = 0x48
		i++
		if m.PreferServerCipherSuites {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.SessionTicketsEnabled {
		data[i] = 0x50
		i++
		if m.SessionTicketsEnabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.SessionTicketKeyID) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintTlsconfig(data, i, uint64(len(m.SessionTicketKeyID)))
		i += copy(data[i:], m.SessionTicketKeyID)
	}
	if m.MinVersion != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintTlsconfig(data, i, uint64(m.MinVersion))
	}
	if m.MaxVersion != 0 {
		data[i] = 0x68
		i++
		i = encodeVarintTlsconfig(data, i, uint64(m.MaxVersion))
	}
	if len(m.CurvePreferences) > 0 {
		for _, num := range m.CurvePreferences {
			data[i] = 0x70
			i++
			i = encodeVarintTlsconfig(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *CertificateAndKeyID) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CertificateAndKeyID) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Certificate) > 0 {
		for _, b := range m.Certificate {
			data[i] = 0xa
			i++
			i = encodeVarintTlsconfig(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if len(m.KeyID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintTlsconfig(data, i, uint64(len(m.KeyID)))
		i += copy(data[i:], m.KeyID)
	}
	if len(m.OCSPStaple) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintTlsconfig(data, i, uint64(len(m.OCSPStaple)))
		i += copy(data[i:], m.OCSPStaple)
	}
	return i, nil
}

func encodeFixed64Tlsconfig(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Tlsconfig(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTlsconfig(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedTLSConfig(r randyTlsconfig, easy bool) *TLSConfig {
	this := &TLSConfig{}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Certificates = make([]*CertificateAndKeyID, v1)
		for i := 0; i < v1; i++ {
			this.Certificates[i] = NewPopulatedCertificateAndKeyID(r, easy)
		}
	}
	v2 := r.Intn(10)
	this.RootCAs = make([][]byte, v2)
	for i := 0; i < v2; i++ {
		v3 := r.Intn(100)
		this.RootCAs[i] = make([]byte, v3)
		for j := 0; j < v3; j++ {
			this.RootCAs[i][j] = byte(r.Intn(256))
		}
	}
	v4 := r.Intn(10)
	this.NextProtos = make([]string, v4)
	for i := 0; i < v4; i++ {
		this.NextProtos[i] = randStringTlsconfig(r)
	}
	this.ServerName = randStringTlsconfig(r)
	this.ClientAuth = ClientAuthType([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	v5 := r.Intn(10)
	this.ClientCAs = make([][]byte, v5)
	for i := 0; i < v5; i++ {
		v6 := r.Intn(100)
		this.ClientCAs[i] = make([]byte, v6)
		for j := 0; j < v6; j++ {
			this.ClientCAs[i][j] = byte(r.Intn(256))
		}
	}
	v7 := r.Intn(10)
	this.CipherSuites = make([]CipherSuite, v7)
	for i := 0; i < v7; i++ {
		this.CipherSuites[i] = CipherSuite([]int32{0, 5, 10, 47, 53, 49159, 49161, 49162, 49169, 49170, 49171, 49172, 49199, 49195, 22016}[r.Intn(15)])
	}
	this.PreferServerCipherSuites = bool(bool(r.Intn(2) == 0))
	this.SessionTicketsEnabled = bool(bool(r.Intn(2) == 0))
	this.SessionTicketKeyID = randStringTlsconfig(r)
	this.MinVersion = TLSVersion([]int32{0, 768, 769, 770, 771}[r.Intn(5)])
	this.MaxVersion = TLSVersion([]int32{0, 768, 769, 770, 771}[r.Intn(5)])
	v8 := r.Intn(10)
	this.CurvePreferences = make([]CurveID, v8)
	for i := 0; i < v8; i++ {
		this.CurvePreferences[i] = CurveID([]int32{0, 23, 24, 25}[r.Intn(4)])
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedCertificateAndKeyID(r randyTlsconfig, easy bool) *CertificateAndKeyID {
	this := &CertificateAndKeyID{}
	v9 := r.Intn(10)
	this.Certificate = make([][]byte, v9)
	for i := 0; i < v9; i++ {
		v10 := r.Intn(100)
		this.Certificate[i] = make([]byte, v10)
		for j := 0; j < v10; j++ {
			this.Certificate[i][j] = byte(r.Intn(256))
		}
	}
	this.KeyID = randStringTlsconfig(r)
	v11 := r.Intn(100)
	this.OCSPStaple = make([]byte, v11)
	for i := 0; i < v11; i++ {
		this.OCSPStaple[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyTlsconfig interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneTlsconfig(r randyTlsconfig) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringTlsconfig(r randyTlsconfig) string {
	v12 := r.Intn(100)
	tmps := make([]rune, v12)
	for i := 0; i < v12; i++ {
		tmps[i] = randUTF8RuneTlsconfig(r)
	}
	return string(tmps)
}
func randUnrecognizedTlsconfig(r randyTlsconfig, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldTlsconfig(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldTlsconfig(data []byte, r randyTlsconfig, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateTlsconfig(data, uint64(key))
		v13 := r.Int63()
		if r.Intn(2) == 0 {
			v13 *= -1
		}
		data = encodeVarintPopulateTlsconfig(data, uint64(v13))
	case 1:
		data = encodeVarintPopulateTlsconfig(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateTlsconfig(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateTlsconfig(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateTlsconfig(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateTlsconfig(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *TLSConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.Certificates) > 0 {
		for _, e := range m.Certificates {
			l = e.Size()
			n += 1 + l + sovTlsconfig(uint64(l))
		}
	}
	if len(m.RootCAs) > 0 {
		for _, b := range m.RootCAs {
			l = len(b)
			n += 1 + l + sovTlsconfig(uint64(l))
		}
	}
	if len(m.NextProtos) > 0 {
		for _, s := range m.NextProtos {
			l = len(s)
			n += 1 + l + sovTlsconfig(uint64(l))
		}
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovTlsconfig(uint64(l))
	}
	if m.ClientAuth != 0 {
		n += 1 + sovTlsconfig(uint64(m.ClientAuth))
	}
	if len(m.ClientCAs) > 0 {
		for _, b := range m.ClientCAs {
			l = len(b)
			n += 1 + l + sovTlsconfig(uint64(l))
		}
	}
	if len(m.CipherSuites) > 0 {
		for _, e := range m.CipherSuites {
			n += 1 + sovTlsconfig(uint64(e))
		}
	}
	if m.PreferServerCipherSuites {
		n += 2
	}
	if m.SessionTicketsEnabled {
		n += 2
	}
	l = len(m.SessionTicketKeyID)
	if l > 0 {
		n += 1 + l + sovTlsconfig(uint64(l))
	}
	if m.MinVersion != 0 {
		n += 1 + sovTlsconfig(uint64(m.MinVersion))
	}
	if m.MaxVersion != 0 {
		n += 1 + sovTlsconfig(uint64(m.MaxVersion))
	}
	if len(m.CurvePreferences) > 0 {
		for _, e := range m.CurvePreferences {
			n += 1 + sovTlsconfig(uint64(e))
		}
	}
	return n
}

func (m *CertificateAndKeyID) Size() (n int) {
	var l int
	_ = l
	if len(m.Certificate) > 0 {
		for _, b := range m.Certificate {
			l = len(b)
			n += 1 + l + sovTlsconfig(uint64(l))
		}
	}
	l = len(m.KeyID)
	if l > 0 {
		n += 1 + l + sovTlsconfig(uint64(l))
	}
	l = len(m.OCSPStaple)
	if l > 0 {
		n += 1 + l + sovTlsconfig(uint64(l))
	}
	return n
}

func sovTlsconfig(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTlsconfig(x uint64) (n int) {
	return sovTlsconfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TLSConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TLSConfig{`,
		`Certificates:` + strings.Replace(fmt.Sprintf("%v", this.Certificates), "CertificateAndKeyID", "CertificateAndKeyID", 1) + `,`,
		`RootCAs:` + fmt.Sprintf("%v", this.RootCAs) + `,`,
		`NextProtos:` + fmt.Sprintf("%v", this.NextProtos) + `,`,
		`ServerName:` + fmt.Sprintf("%v", this.ServerName) + `,`,
		`ClientAuth:` + fmt.Sprintf("%v", this.ClientAuth) + `,`,
		`ClientCAs:` + fmt.Sprintf("%v", this.ClientCAs) + `,`,
		`CipherSuites:` + fmt.Sprintf("%v", this.CipherSuites) + `,`,
		`PreferServerCipherSuites:` + fmt.Sprintf("%v", this.PreferServerCipherSuites) + `,`,
		`SessionTicketsEnabled:` + fmt.Sprintf("%v", this.SessionTicketsEnabled) + `,`,
		`SessionTicketKeyID:` + fmt.Sprintf("%v", this.SessionTicketKeyID) + `,`,
		`MinVersion:` + fmt.Sprintf("%v", this.MinVersion) + `,`,
		`MaxVersion:` + fmt.Sprintf("%v", this.MaxVersion) + `,`,
		`CurvePreferences:` + fmt.Sprintf("%v", this.CurvePreferences) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CertificateAndKeyID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CertificateAndKeyID{`,
		`Certificate:` + fmt.Sprintf("%v", this.Certificate) + `,`,
		`KeyID:` + fmt.Sprintf("%v", this.KeyID) + `,`,
		`OCSPStaple:` + fmt.Sprintf("%v", this.OCSPStaple) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTlsconfig(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TLSConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTlsconfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTlsconfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificates = append(m.Certificates, &CertificateAndKeyID{})
			if err := m.Certificates[len(m.Certificates)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootCAs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTlsconfig
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootCAs = append(m.RootCAs, make([]byte, postIndex-iNdEx))
			copy(m.RootCAs[len(m.RootCAs)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextProtos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTlsconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextProtos = append(m.NextProtos, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTlsconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientAuth", wireType)
			}
			m.ClientAuth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ClientAuth |= (ClientAuthType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientCAs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTlsconfig
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientCAs = append(m.ClientCAs, make([]byte, postIndex-iNdEx))
			copy(m.ClientCAs[len(m.ClientCAs)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherSuites", wireType)
			}
			var v CipherSuite
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (CipherSuite(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CipherSuites = append(m.CipherSuites, v)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferServerCipherSuites", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreferServerCipherSuites = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionTicketsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SessionTicketsEnabled = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionTicketKeyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTlsconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionTicketKeyID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVersion", wireType)
			}
			m.MinVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MinVersion |= (TLSVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxVersion", wireType)
			}
			m.MaxVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MaxVersion |= (TLSVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurvePreferences", wireType)
			}
			var v CurveID
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (CurveID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CurvePreferences = append(m.CurvePreferences, v)
		default:
			iNdEx = preIndex
			skippy, err := skipTlsconfig(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTlsconfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateAndKeyID) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTlsconfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateAndKeyID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateAndKeyID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTlsconfig
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = append(m.Certificate, make([]byte, postIndex-iNdEx))
			copy(m.Certificate[len(m.Certificate)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTlsconfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OCSPStaple", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTlsconfig
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OCSPStaple = append(m.OCSPStaple[:0], data[iNdEx:postIndex]...)
			if m.OCSPStaple == nil {
				m.OCSPStaple = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTlsconfig(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTlsconfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTlsconfig(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTlsconfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTlsconfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTlsconfig
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTlsconfig
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTlsconfig(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTlsconfig = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTlsconfig   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorTlsconfig = []byte{
	// 940 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x94, 0x4d, 0x6c, 0xe3, 0x44,
	0x14, 0xc7, 0x9b, 0x6d, 0x93, 0x36, 0x2f, 0x6d, 0x70, 0x67, 0xd5, 0x8d, 0x69, 0x97, 0x6c, 0x29,
	0x0b, 0x2c, 0x01, 0xfa, 0x91, 0x6e, 0x4b, 0x25, 0x04, 0xc2, 0x71, 0xdc, 0xad, 0xb5, 0x21, 0x0d,
	0x76, 0xb6, 0x88, 0xd3, 0xc8, 0x75, 0xa6, 0xad, 0xd5, 0xd6, 0x8e, 0x62, 0x07, 0xb5, 0x9c, 0x0a,
	0x1c, 0x10, 0xdc, 0xf8, 0xb8, 0x73, 0x45, 0x02, 0x89, 0x2b, 0x12, 0x17, 0x8e, 0x70, 0xdb, 0x23,
	0x27, 0xb4, 0xdb, 0x13, 0xc7, 0x3d, 0x72, 0xe4, 0xcd, 0x38, 0xa9, 0xed, 0x24, 0x94, 0xc3, 0x6b,
	0x67, 0xde, 0xff, 0xf7, 0x66, 0xde, 0xfc, 0xf3, 0x64, 0x78, 0x2e, 0x38, 0xf1, 0x6d, 0xcf, 0x3d,
	0x70, 0x0e, 0x97, 0xdb, 0x1d, 0x2f, 0xf0, 0x48, 0x5a, 0xfc, 0x9b, 0x5f, 0x3d, 0x74, 0x82, 0xa3,
	0xee, 0xfe, 0xb2, 0xed, 0x9d, 0xae, 0x9c, 0x5a, 0x2d, 0x27, 0x38, 0xb7, 0x56, 0x84, 0xb2, 0xdf,
	0x3d, 0x58, 0x39, 0xf4, 0x0e, 0x3d, 0xb1, 0x11, 0xab, 0xb0, 0x70, 0xe9, 0xd7, 0x34, 0x64, 0x9b,
	0x35, 0x53, 0x15, 0x87, 0x91, 0x77, 0x61, 0xda, 0x66, 0x9d, 0xc0, 0x39, 0x70, 0x6c, 0x2b, 0x60,
	0xbe, 0x9c, 0x5a, 0x1c, 0xbf, 0x97, 0x2b, 0xcf, 0x87, 0xec, 0xb2, 0x1a, 0x49, 0x8a, 0xdb, 0x7a,
	0xc8, 0xce, 0xf5, 0xaa, 0x91, 0xe0, 0xc9, 0x2b, 0x30, 0xd5, 0xf1, 0xbc, 0x80, 0xda, 0x96, 0x2f,
	0x8f, 0x63, 0xed, 0x74, 0x25, 0x77, 0xf9, 0xd7, 0x9d, 0x49, 0x03, 0x73, 0xaa, 0xe2, 0x1b, 0x93,
	0x5c, 0x54, 0x2d, 0x9f, 0xdc, 0x81, 0x9c, 0xcb, 0xce, 0x02, 0x2a, 0xce, 0xf5, 0xe5, 0x09, 0x44,
	0xb3, 0x06, 0xf0, 0x54, 0x43, 0x64, 0x38, 0xe0, 0xb3, 0xce, 0xc7, 0xac, 0x43, 0x5d, 0xeb, 0x94,
	0xc9, 0xe9, 0xc5, 0x14, 0x07, 0xc2, 0x54, 0x1d, 0x33, 0x64, 0x13, 0x72, 0xf6, 0x89, 0xc3, 0xdc,
	0x80, 0x5a, 0xdd, 0xe0, 0x48, 0xce, 0x20, 0x90, 0x2f, 0xcf, 0xf5, 0x1b, 0x15, 0x8a, 0x82, 0x42,
	0xf3, 0xbc, 0xcd, 0x0c, 0xb0, 0xaf, 0xf6, 0xe4, 0x0d, 0xe8, 0xed, 0x44, 0x8f, 0x93, 0xa2, 0xc7,
	0x19, 0xec, 0x31, 0x1b, 0xd6, 0xf0, 0x2e, 0xb3, 0x21, 0xc0, 0xfb, 0x7c, 0x0b, 0x66, 0x6c, 0xa7,
	0x7d, 0x84, 0x6d, 0xf8, 0x5d, 0x87, 0x1b, 0x32, 0x85, 0x05, 0xf9, 0x32, 0xe9, 0xdf, 0x23, 0x34,
	0x93, 0x4b, 0x68, 0x44, 0xb4, 0xf1, 0xc9, 0x3b, 0xb0, 0xd0, 0xee, 0xb0, 0x03, 0x5e, 0x18, 0x3e,
	0x23, 0x79, 0x4c, 0x16, 0xdb, 0x9d, 0x32, 0xe4, 0x10, 0x31, 0x05, 0xa1, 0xc6, 0xcb, 0x37, 0xa1,
	0xe0, 0x33, 0xdf, 0x77, 0x3c, 0x97, 0x06, 0x8e, 0x7d, 0xcc, 0x02, 0x9f, 0x32, 0xd7, 0xda, 0x3f,
	0x61, 0x2d, 0x19, 0x44, 0xe9, 0x5c, 0x4f, 0x6e, 0x86, 0xaa, 0x16, 0x8a, 0x44, 0x87, 0xb9, 0x64,
	0x1d, 0x3d, 0x66, 0xe7, 0xd4, 0x69, 0xc9, 0x39, 0x6e, 0x60, 0xe5, 0x16, 0x3e, 0x94, 0x98, 0xf1,
	0xca, 0xf0, 0x47, 0x24, 0xfe, 0x60, 0xae, 0x45, 0xca, 0x90, 0x3b, 0x75, 0x5c, 0x8a, 0x9d, 0x71,
	0x45, 0x9e, 0x16, 0x06, 0xcf, 0xf6, 0x1e, 0x8e, 0x13, 0xb3, 0x17, 0x0a, 0x06, 0x20, 0xd5, 0x5b,
	0x8b, 0x1a, 0xeb, 0xec, 0xaa, 0x66, 0xe6, 0xbf, 0x6b, 0xac, 0xb3, 0x7e, 0xcd, 0xdb, 0x30, 0x6b,
	0x77, 0xd1, 0x00, 0x1a, 0x9a, 0xc1, 0x5c, 0x1b, 0xfd, 0xc9, 0x0b, 0x9b, 0xf3, 0x7d, 0x9b, 0xb9,
	0x8e, 0x6d, 0x4a, 0x02, 0x6c, 0x44, 0xdc, 0xd2, 0x27, 0x70, 0x73, 0xc4, 0x50, 0x92, 0x45, 0x1c,
	0x8e, 0x28, 0x2d, 0xa6, 0x78, 0xda, 0x88, 0xa7, 0x90, 0xc8, 0xf4, 0x9c, 0xb9, 0x21, 0x9c, 0xc9,
	0xa2, 0x33, 0xe9, 0xd0, 0x8c, 0xf4, 0xb1, 0x78, 0x3f, 0x4e, 0xe0, 0xae, 0x6a, 0x36, 0xa8, 0x1f,
	0x58, 0xed, 0x13, 0x86, 0xd3, 0x9c, 0xc2, 0x33, 0xc0, 0xc3, 0x94, 0x29, 0x32, 0xa5, 0x33, 0x80,
	0xe8, 0x49, 0x64, 0x1e, 0x6e, 0x45, 0x3b, 0xfa, 0xa8, 0x6e, 0x36, 0x34, 0x55, 0xdf, 0xd6, 0xb5,
	0xaa, 0x34, 0x46, 0x08, 0xcc, 0xec, 0x69, 0x86, 0xa9, 0xef, 0xd6, 0xa9, 0x69, 0xd6, 0xd6, 0x57,
	0xa5, 0x8b, 0x4c, 0x3c, 0x87, 0x75, 0x6b, 0xab, 0xd2, 0xa7, 0x43, 0xb9, 0x35, 0xe9, 0xb3, 0xa1,
	0x5c, 0x59, 0xfa, 0x3c, 0x53, 0xfa, 0x3e, 0x05, 0xf9, 0xe4, 0x88, 0x23, 0x96, 0xaf, 0xef, 0x52,
	0xb5, 0xa6, 0x6b, 0xf5, 0x26, 0x55, 0x35, 0xa3, 0x89, 0xd7, 0x16, 0xe0, 0xa6, 0xa1, 0x7d, 0xf0,
	0x48, 0x33, 0x9b, 0x09, 0x21, 0x45, 0x16, 0xa0, 0xc0, 0x05, 0xdd, 0xd0, 0xa8, 0x52, 0xff, 0x28,
	0x21, 0xde, 0xc0, 0x77, 0x2f, 0xe0, 0x85, 0xfa, 0x76, 0x22, 0x4f, 0xf5, 0x6d, 0xfa, 0x40, 0xdf,
	0xd3, 0xea, 0xd2, 0x38, 0x59, 0x82, 0x62, 0x54, 0x5d, 0xa5, 0xc3, 0xb0, 0x34, 0x51, 0xfa, 0x63,
	0x02, 0x72, 0xb1, 0x81, 0xe6, 0x37, 0xc6, 0xb6, 0x03, 0xf6, 0xdc, 0x06, 0x19, 0x9f, 0x46, 0x0d,
	0x53, 0xa1, 0x1f, 0xea, 0xcd, 0x1d, 0x6a, 0xa8, 0xf7, 0xe9, 0x5a, 0x79, 0x8b, 0x9a, 0x3b, 0x8a,
	0x94, 0x26, 0x2f, 0xc2, 0x0b, 0x09, 0x75, 0xbd, 0xaa, 0x99, 0x54, 0xab, 0x6a, 0x54, 0xad, 0xa8,
	0x02, 0x01, 0xfc, 0x31, 0x6f, 0x27, 0x10, 0x05, 0x09, 0x7e, 0x40, 0x9f, 0x58, 0x19, 0x49, 0x94,
	0x37, 0x36, 0xaf, 0x88, 0x0d, 0xfc, 0x72, 0x2d, 0x72, 0x42, 0x53, 0xab, 0x3b, 0x1a, 0xff, 0x3b,
	0xaa, 0x99, 0x2f, 0x2e, 0xc6, 0x49, 0x09, 0xee, 0x8e, 0xe4, 0x06, 0xef, 0xfc, 0xf2, 0x7f, 0xd8,
	0xf8, 0xed, 0x5f, 0x21, 0x7b, 0x17, 0x8a, 0x11, 0x3b, 0xd2, 0x8a, 0xaf, 0x91, 0x7a, 0x0d, 0x5e,
	0x1a, 0x41, 0x0d, 0x59, 0xf2, 0x0d, 0xa2, 0xf7, 0x60, 0x69, 0x04, 0x3a, 0xd8, 0xe6, 0xb7, 0xd7,
	0x92, 0xf1, 0x26, 0xbf, 0x43, 0xf2, 0x75, 0x78, 0xf9, 0x9a, 0x33, 0x1f, 0xa8, 0xef, 0x73, 0x12,
	0x8b, 0xa4, 0x9f, 0x11, 0x7e, 0x13, 0x5e, 0xbd, 0xd6, 0xa9, 0x18, 0xfe, 0x23, 0xe2, 0x05, 0x98,
	0xe5, 0xf8, 0xb6, 0x52, 0xab, 0x55, 0x14, 0xf5, 0x21, 0x35, 0x55, 0x73, 0x4f, 0xba, 0xf8, 0x29,
	0x55, 0x7a, 0x0f, 0x26, 0x7b, 0x1f, 0x00, 0x3e, 0xd1, 0xbd, 0xe5, 0xc0, 0x08, 0x4d, 0xc1, 0x44,
	0x83, 0x1f, 0x54, 0x10, 0xab, 0xf5, 0xad, 0xfb, 0x92, 0x2c, 0x56, 0x1b, 0xe5, 0x35, 0xe9, 0xf9,
	0xca, 0xd6, 0xe3, 0xa7, 0xc5, 0xb1, 0x3f, 0x31, 0x9e, 0x3c, 0x2d, 0xa6, 0x9e, 0x61, 0xfc, 0x83,
	0x71, 0x71, 0x59, 0x4c, 0xfd, 0x80, 0xf1, 0x0b, 0xc6, 0x6f, 0x18, 0xbf, 0x63, 0x3c, 0xc6, 0x78,
	0x82, 0xf1, 0xf7, 0x65, 0x71, 0xec, 0x19, 0xfe, 0xdf, 0xcf, 0x88, 0x0f, 0xd0, 0xfa, 0xbf, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x6e, 0x63, 0xdf, 0xfc, 0x70, 0x07, 0x00, 0x00,
}
