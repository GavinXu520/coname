// Code generated by protoc-gen-gogo.
// source: client.proto
// DO NOT EDIT!

/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		client.proto
		config.proto
		duration.proto
		keyserverconfig.proto
		local.proto
		replication.proto
		timestamp.proto
		tlsconfig.proto
		verifier.proto

	It has these top-level messages:
		LookupRequest
		UpdateRequest
		LookupProof
		TreeProof
		Entry
		SignedEntryUpdate
		Profile
		SignedEpochHead
		TimestampedEpochHead
		EpochHead
		AuthorizationPolicy
		PublicKey
		QuorumExpr
*/
package proto

// discarding unused import gogoproto "gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import fmt "fmt"
import bytes "bytes"

import strings "strings"
import github_com_andres_erbsen_protobuf_proto "github.com/andres-erbsen/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"
import github_com_andres_erbsen_protobuf_sortkeys "github.com/andres-erbsen/protobuf/sortkeys"

import errors "errors"

import io "io"

type LookupRequest struct {
	// Epoch as of which to perform the lookup ("latest" if not specified)
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// UserId will be mapped to an index by the server using VRF
	UserId string `protobuf:"bytes,2,opt,name=user_id,proto3" json:"user_id,omitempty"`
	// The client specifies it
	Index []byte `protobuf:"bytes,3,opt,name=index,proto3" json:"index,omitempty"`
	// quorum_requirement specifies which verifiers must have ratified the
	// result for it to be accepted. A server would fall back to an older
	// directory state if the ratifications of the latest one do not satisfy
	// the quourm requirement.
	QuorumRequirement *QuorumExpr `protobuf:"bytes,4,opt,name=quorum_requirement" json:"quorum_requirement,omitempty"`
}

func (m *LookupRequest) Reset()      { *m = LookupRequest{} }
func (*LookupRequest) ProtoMessage() {}

func (m *LookupRequest) GetQuorumRequirement() *QuorumExpr {
	if m != nil {
		return m.QuorumRequirement
	}
	return nil
}

// UpdateRequest specifies an update and the quorum required for
// considering the update successful. The server should respond with a lookup
// of the updated name with the specified parameters.
type UpdateRequest struct {
	// Update is passed on to verifiers.
	Update *SignedEntryUpdate `protobuf:"bytes,1,opt,name=update" json:"update,omitempty"`
	// Profile is included in the update request from the client to the
	// keyserver, but not passed on to the verifiers. The keyserver SHOULD
	// store it locally and include it in LookupProofs returned for lookups.
	// The verifiers MUST NOT try to read this field.
	// A keyserver MUST NOT discriminate users based on ther structure of their
	// profile other than enforcing a common-sense size limit. In particular, a
	// profile with fields that the keyserver does not understand or whose
	// values it considers invalid MUST be accepted.
	Profile          Profile_PreserveEncoding `protobuf:"bytes,2,opt,name=profile,customtype=Profile_PreserveEncoding" json:"profile"`
	LookupParameters *LookupRequest           `protobuf:"bytes,3,opt,name=lookup_parameters" json:"lookup_parameters,omitempty"`
	// UserID specifies the id for the new account to be registered.
	UserID    string `protobuf:"bytes,1000,opt,name=user_id,proto3" json:"user_id,omitempty"`
	DKIMProof []byte `protobuf:"bytes,1001,opt,name=dkim_proof,proto3" json:"dkim_proof,omitempty"`
}

func (m *UpdateRequest) Reset()      { *m = UpdateRequest{} }
func (*UpdateRequest) ProtoMessage() {}

func (m *UpdateRequest) GetUpdate() *SignedEntryUpdate {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *UpdateRequest) GetLookupParameters() *LookupRequest {
	if m != nil {
		return m.LookupParameters
	}
	return nil
}

// LookupProof encapsulates end-to-end cryptographc evidence that assuming *at
// least one* of the ratifiers has been correctly following the rules of the
// keyserver protocol then profile contains the latest public keys and metadata
// uploaded by user_id before the time specified in ratifications[0]. If any
// step of the proof does not check out, the contents of profile MUST NOT be
// used for any other purpose than debugging.
type LookupProof struct {
	UserId string `protobuf:"bytes,1,opt,name=user_id,proto3" json:"user_id,omitempty"`
	// index proof that index is a result of applying a globally fixed
	// bijection VRF to user_id: idx = VRF(user_ID). If this proof checks out,
	// we can safely continue by looking up the keyserver entry corresponding
	// to index to get the public key of user_id.
	IndexProof []byte `protobuf:"bytes,2,opt,name=index_proof,proto3" json:"index_proof,omitempty"`
	// ratifications contains signed directory state summaries for the epoch under
	// which the lookup was performed.
	// A single valid ratification r by a honest and correct verifier implies
	// that the r.ratification.summary.root_hash summarizes the authenticated
	// data structure containing the unique and correct mapping from indices to
	// entries as of epoch r.ratification.epoch at human time
	// r.ratification.timestamp.
	// Each ratification must contain the same epoch head. A client MUST ignore a
	// proof if the ratifications do not satisfy its quorum requirement and MUST
	// require the keyserver itself to be in the quorum.
	Ratifications []*SignedEpochHead `protobuf:"bytes,3,rep,name=ratifications" json:"ratifications,omitempty"`
	// tree_proof contains an authenticated data structure lookup trace,
	// arguing that index maps to entry in the data structure with hash
	// ratifications[0].ratification.summary.root_hash.
	TreeProof *TreeProof `protobuf:"bytes,4,opt,name=tree_proof" json:"tree_proof,omitempty"`
	// Entry specifies profile by hash(profile) = entry.profile_hash
	Entry   Entry_PreserveEncoding   `protobuf:"bytes,5,opt,name=entry,customtype=Entry_PreserveEncoding" json:"entry"`
	Profile Profile_PreserveEncoding `protobuf:"bytes,6,opt,name=profile,customtype=Profile_PreserveEncoding" json:"profile"`
}

func (m *LookupProof) Reset()      { *m = LookupProof{} }
func (*LookupProof) ProtoMessage() {}

func (m *LookupProof) GetRatifications() []*SignedEpochHead {
	if m != nil {
		return m.Ratifications
	}
	return nil
}

func (m *LookupProof) GetTreeProof() *TreeProof {
	if m != nil {
		return m.TreeProof
	}
	return nil
}

// A Proof provides an authentication path through the Merkle Tree that
// proves that an item is or is not present in the tree.
type TreeProof struct {
	// Neighbors is a list of all the adacent nodes along the path from the
	// bottommost node to the root. To save space, hashes for empty subtrees are
	// nil, and the number of hashes is equal to the length of the longest common
	// prefix with another entry in the tree (since a leaf node is moved up to
	// that point -- subtrees with a single entry are coalesced into a single
	// node).
	Neighbors [][]byte `protobuf:"bytes,1,rep,name=neighbors" json:"neighbors,omitempty"`
	// This is the index for the binding that does exist; it will share a prefix
	// with vuf, but in case the leaf contains the wrong contents, it will be
	// different. It will be nil if the requested VRF falls under an empty branch.
	ExistingIndex []byte `protobuf:"bytes,2,opt,name=existing_index,proto3" json:"existing_index,omitempty"`
	// This is the hash of the entry for the binding that does exist. If the leaf
	// contains the wrong contents, the client can use this to verify that it in
	// fact is at that position in the tree.
	ExistingEntryHash []byte `protobuf:"bytes,3,opt,name=existing_entry_hash,proto3" json:"existing_entry_hash,omitempty"`
}

func (m *TreeProof) Reset()      { *m = TreeProof{} }
func (*TreeProof) ProtoMessage() {}

// Entry is the value type in the authenticated mapping data structure.  The
// contents of all entries should be considered public (they are served to
// verifiers).
type Entry struct {
	// Index specifies the location of the entry in the authenticated
	// mapping data structure. It is computed as a verifiable random
	// function of the name: the keyserver can prove that index=vrf(name)
	// to anybody, but nobody else can compute vrf(name1). This is to
	// maintain the privacy of usernames.
	Index []byte `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	// Version starts at 0 at registration and must not decrease. The keyserver
	// and verifiers MUST reject SignedEntryUpdates which violate these rules.
	// The purpose of this is to prevent an attacker from replaying a
	// SignedEntryUpdate that publishes a key that the attacker has gained
	// control of. On the other hand, increases by more than one are allowed: a
	// user should be allowed to generate a long-lived offline revocation
	// certificate that is valid even after they make some other change to
	// their profile. Nevertheless, unless explicitly required otherwise,
	// clients should increase the version number by exactly one on each
	// update.
	Version uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// UpdatePolicy will be used to verify SignedEntryUpdates to this
	// entry. It is NOT used for encryption, and SHOULD be ignored by
	// applications that do not intend to manage the user's profile. It has
	// also been called "the public key of the profile signing key" or "the
	// public identity key". A keyserver MUST NOT discriminate users based on
	// ther structure of their update_key other than (1) as specified in
	// SignedEntryUpdate and (2) common-sense limits on the total size of an
	// entry to limit storage cost.
	UpdatePolicy *AuthorizationPolicy `protobuf:"bytes,3,opt,name=update_policy" json:"update_policy,omitempty"`
	// The entry uniquely specifies the profile using a collision-resistant
	// hash function.
	ProfileHash []byte `protobuf:"bytes,4,opt,name=profile_hash,proto3" json:"profile_hash,omitempty"`
}

func (m *Entry) Reset()      { *m = Entry{} }
func (*Entry) ProtoMessage() {}

func (m *Entry) GetUpdatePolicy() *AuthorizationPolicy {
	if m != nil {
		return m.UpdatePolicy
	}
	return nil
}

// SignedEntryUpdate is the minimal self-contained structure to justify
// changing the value of an entry. In the state machine model of a namespace,
// SignedEntryUpdate is the main input type.
type SignedEntryUpdate struct {
	NewEntry Entry_PreserveEncoding `protobuf:"bytes,1,opt,name=new_entry,customtype=Entry_PreserveEncoding" json:"new_entry"`
	// NewSig, if successfully verified using update.new_entry.update_key,
	// confirms that the new entry is willing to be bound to this index.
	// Both the keyserver and verifiers MUST check these signatures against the
	// old profile's authorization policy AND the new profile's authorization
	// policy. All signatures are tagged with ID of the public key that
	// generated them.
	Signatures map[uint64][]byte `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SignedEntryUpdate) Reset()      { *m = SignedEntryUpdate{} }
func (*SignedEntryUpdate) ProtoMessage() {}

func (m *SignedEntryUpdate) GetSignatures() map[uint64][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// A user's profile, containing public keys and other information.
// A new field will be added here for each application, with the TCP/UDP port
// number as field number whenever possible to avoid collisions.
type Profile struct {
	// Nonce containst at least 16 bytes (and counts towards the total profile
	// size limit). Having a nonce in each profile ensures that an attacker
	// curious guess-and-check somebody's profile contents using
	// Entry.profile_hash. It is the client's responsibility to generate a
	// random nonce to protect the privacy of its profile, thus the presence of
	// this field is not checked by the server.
	Nonce []byte `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Application-specific public keys. The map is keyed by application ID.
	Keys map[string][]byte `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Profile) Reset()      { *m = Profile{} }
func (*Profile) ProtoMessage() {}

func (m *Profile) GetKeys() map[string][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// SignedEpochHead messages are used by auditors and the service provider to
// vouch that the SummaryHash represents the correct unique global state at the
// end of epoch. In particular, it means that the signer has enforced the
// profile update policy specified in the doc-comments of SignedEntryUpdate and
// Profile for the specified epoch AND all prior epochs. A Ratification MUST
// NOT be signed in any other circumstances.
type SignedEpochHead struct {
	Head TimestampedEpochHead_PreserveEncoding `protobuf:"bytes,1,opt,name=head,customtype=TimestampedEpochHead_PreserveEncoding" json:"head"`
	// Signatures is used for authentication of ratification and MUST be
	// verified before interpreting any contents of ratification.
	// All signatures are tagged with ID of the public key that generated them.
	Signatures map[uint64][]byte `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SignedEpochHead) Reset()      { *m = SignedEpochHead{} }
func (*SignedEpochHead) ProtoMessage() {}

func (m *SignedEpochHead) GetSignatures() map[uint64][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type TimestampedEpochHead struct {
	// EpochHead specifies the entire state and history of the
	// realm.
	Head EpochHead_PreserveEncoding `protobuf:"bytes,1,opt,name=head,customtype=EpochHead_PreserveEncoding" json:"head"`
	// Timestamp specifies when the requirements for SignedEpochHead
	// were checked. Clients will accept a SignedEpochHead timestamped
	// with at most a fixed amount of time into the past, and MUST fail
	// secure if the timestamp is not fresh because the directory state may
	// have changed. The signature expiration tolerance plus the maximum
	// clock skew between a pair of clients is the maximum propogation time
	// of a change from one to another after which even a malicious
	// keyserve will not be able to convince a client to a accept the
	// previous state (assuming that all quorums it considers sufficient
	// containt a correct and honest server).
	Timestamp Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
}

func (m *TimestampedEpochHead) Reset()      { *m = TimestampedEpochHead{} }
func (*TimestampedEpochHead) ProtoMessage() {}

func (m *TimestampedEpochHead) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

type EpochHead struct {
	// Realm is the fully-qualified domain name of the keyserver whose
	// state is being ratified.
	Realm string `protobuf:"bytes,1,opt,name=realm,proto3" json:"realm,omitempty"`
	// Epoch is a sequence number tracking distinct ratified states.
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// RootHash specifies the authenticated data structure.
	RootHash []byte `protobuf:"bytes,3,opt,name=root_hash,proto3" json:"root_hash,omitempty"`
	// PreviousSummaryHash chaining is used to allow signatures from
	// different epochs in the same quorum: a signature vouches for all
	// epochs chained to that in addition to the one listed.
	// Each PreviousSummaryHash depends on PreviousSummary, therefore
	// (by induction on the hash-pointer structure) a
	// PreviousSummeryHash for some epoch specifies the states of all
	// previous epochs.
	PreviousSummaryHash []byte `protobuf:"bytes,4,opt,name=previous_summary_hash,proto3" json:"previous_summary_hash,omitempty"`
	// NextEpochTime MUST contain the time by which the server plans to sign
	// and publish the next epoch after this one. The server SHOULD give a
	// sufficiently pessimistic estimate that, for example, a replicated
	// state-machine failover would not prevent it from being met. To maintain
	// a monotonic view of the directory, a server MUST NOT issue an epoch i
	// with a smaller next_epoch_time than was used for epoch i-1, and if it
	// does, verifiers MUST NOT sign it.
	NextEpochTime Timestamp `protobuf:"bytes,5,opt,name=next_epoch_time" json:"next_epoch_time"`
	// NextEpochPolicy allows for automated server key rollover: the new key(s)
	// are signed by the current one as a part of the epoch. This field is nil
	// if no key change is requested. If the server key is distributed with the
	// client software and benefits from reliable automated updates, clients
	// MAY ignore this field.
	NextEpochPolicy AuthorizationPolicy `protobuf:"bytes,6,opt,name=next_epoch_policy" json:"next_epoch_policy"`
}

func (m *EpochHead) Reset()      { *m = EpochHead{} }
func (*EpochHead) ProtoMessage() {}

func (m *EpochHead) GetNextEpochTime() Timestamp {
	if m != nil {
		return m.NextEpochTime
	}
	return Timestamp{}
}

func (m *EpochHead) GetNextEpochPolicy() AuthorizationPolicy {
	if m != nil {
		return m.NextEpochPolicy
	}
	return AuthorizationPolicy{}
}

// AuthorizationPolicy is used to check whether some signatures make up
// sufficient authorization to back an action.
// This is used to implement the following:
// 1. Account Recovery through service provider: if an user's entry has the
// update key set to threshold(1,user,serviceprovider), the service
// provider can perform account recovery. Note that a third party will not
// necessarily know who the subkeys are held by. Thus, the client
// implementation MUST require a signed certificate confirming possession
// of the secret key and promising to do no evil from every trustee whose
// key is used for recovery in this manner.
// 2. Service providers with servers in geographically diverse locations
// can use a threshold to limit the damage the compromise or loss of one
// replica can do. Example threshold(2,freedonia,gilead,mordor).
// 3. Adaptive key rollover during cryptocalypse.
type AuthorizationPolicy struct {
	PublicKeys map[uint64]*PublicKey `protobuf:"bytes,1,rep,name=public_keys" json:"public_keys,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Quorum     *QuorumExpr           `protobuf:"bytes,2,opt,name=quorum" json:"quorum,omitempty"`
}

func (m *AuthorizationPolicy) Reset()      { *m = AuthorizationPolicy{} }
func (*AuthorizationPolicy) ProtoMessage() {}

func (m *AuthorizationPolicy) GetPublicKeys() map[uint64]*PublicKey {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func (m *AuthorizationPolicy) GetQuorum() *QuorumExpr {
	if m != nil {
		return m.Quorum
	}
	return nil
}

// PublicKey wraps a public key of a cryptographically secure signature
// scheme and verification metadata. Each verifier can have its own signature
// format and needs to implement serialization and deserialization of its own
// signatures. The ID of a public key is defined as the first 64 bits of the
// protobuf-encoded public key (and interpreted as little-endian when a numeric
// representation is required).
type PublicKey struct {
	Ed25519 []byte `protobuf:"bytes,1,opt,name=ed25519,proto3" json:"ed25519,omitempty"`
}

func (m *PublicKey) Reset()      { *m = PublicKey{} }
func (*PublicKey) ProtoMessage() {}

// QuorumExpr represents a function with type set<uint64> -> bool. An
// expression evaluates to true given args iff the sum of the following two
// numbers is at least threshold:
// - number of entries in verifiers that are in args
// - number of subexpressions that evaluate to true
// note: expr.eval(a) \wedge expr.eval(b) -> expr.eval(a \cup b)
type QuorumExpr struct {
	Threshold  uint32   `protobuf:"varint,1,opt,name=threshold,proto3" json:"threshold,omitempty"`
	Candidates []uint64 `protobuf:"fixed64,2,rep,name=candidates" json:"candidates,omitempty"`
	// QuorumExpr allows expressing contitions of the form "two out of these
	// and three out of those".
	// If an implementation chooses to ban recursive thresholding, it can do so
	// ignoring this field. However, doing so is NOT SUPPORTED.
	Subexpressions []*QuorumExpr `protobuf:"bytes,3,rep,name=subexpressions" json:"subexpressions,omitempty"`
}

func (m *QuorumExpr) Reset()      { *m = QuorumExpr{} }
func (*QuorumExpr) ProtoMessage() {}

func (m *QuorumExpr) GetSubexpressions() []*QuorumExpr {
	if m != nil {
		return m.Subexpressions
	}
	return nil
}

// Client API for E2EKSLookup service

type E2EKSLookupClient interface {
	Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupProof, error)
}

type e2EKSLookupClient struct {
	cc *grpc.ClientConn
}

func NewE2EKSLookupClient(cc *grpc.ClientConn) E2EKSLookupClient {
	return &e2EKSLookupClient{cc}
}

func (c *e2EKSLookupClient) Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupProof, error) {
	out := new(LookupProof)
	err := grpc.Invoke(ctx, "/proto.E2EKSLookup/Lookup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for E2EKSLookup service

type E2EKSLookupServer interface {
	Lookup(context.Context, *LookupRequest) (*LookupProof, error)
}

func RegisterE2EKSLookupServer(s *grpc.Server, srv E2EKSLookupServer) {
	s.RegisterService(&_E2EKSLookup_serviceDesc, srv)
}

func _E2EKSLookup_Lookup_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(LookupRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKSLookupServer).Lookup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _E2EKSLookup_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.E2EKSLookup",
	HandlerType: (*E2EKSLookupServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Lookup",
			Handler:    _E2EKSLookup_Lookup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for E2EKSUpdate service

type E2EKSUpdateClient interface {
	Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupProof, error)
	Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*LookupProof, error)
}

type e2EKSUpdateClient struct {
	cc *grpc.ClientConn
}

func NewE2EKSUpdateClient(cc *grpc.ClientConn) E2EKSUpdateClient {
	return &e2EKSUpdateClient{cc}
}

func (c *e2EKSUpdateClient) Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupProof, error) {
	out := new(LookupProof)
	err := grpc.Invoke(ctx, "/proto.E2EKSUpdate/Lookup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKSUpdateClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*LookupProof, error) {
	out := new(LookupProof)
	err := grpc.Invoke(ctx, "/proto.E2EKSUpdate/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for E2EKSUpdate service

type E2EKSUpdateServer interface {
	Lookup(context.Context, *LookupRequest) (*LookupProof, error)
	Update(context.Context, *UpdateRequest) (*LookupProof, error)
}

func RegisterE2EKSUpdateServer(s *grpc.Server, srv E2EKSUpdateServer) {
	s.RegisterService(&_E2EKSUpdate_serviceDesc, srv)
}

func _E2EKSUpdate_Lookup_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(LookupRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKSUpdateServer).Lookup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _E2EKSUpdate_Update_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(UpdateRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKSUpdateServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _E2EKSUpdate_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.E2EKSUpdate",
	HandlerType: (*E2EKSUpdateServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Lookup",
			Handler:    _E2EKSUpdate_Lookup_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _E2EKSUpdate_Update_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (this *LookupRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LookupRequest)
	if !ok {
		return fmt.Errorf("that is not of type *LookupRequest")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LookupRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LookupRequestbut is not nil && this == nil")
	}
	if this.Epoch != that1.Epoch {
		return fmt.Errorf("Epoch this(%v) Not Equal that(%v)", this.Epoch, that1.Epoch)
	}
	if this.UserId != that1.UserId {
		return fmt.Errorf("UserId this(%v) Not Equal that(%v)", this.UserId, that1.UserId)
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return fmt.Errorf("Index this(%v) Not Equal that(%v)", this.Index, that1.Index)
	}
	if !this.QuorumRequirement.Equal(that1.QuorumRequirement) {
		return fmt.Errorf("QuorumRequirement this(%v) Not Equal that(%v)", this.QuorumRequirement, that1.QuorumRequirement)
	}
	return nil
}
func (this *LookupRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LookupRequest)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return false
	}
	if !this.QuorumRequirement.Equal(that1.QuorumRequirement) {
		return false
	}
	return true
}
func (this *UpdateRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateRequest)
	if !ok {
		return fmt.Errorf("that is not of type *UpdateRequest")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateRequestbut is not nil && this == nil")
	}
	if !this.Update.Equal(that1.Update) {
		return fmt.Errorf("Update this(%v) Not Equal that(%v)", this.Update, that1.Update)
	}
	if !this.Profile.Equal(that1.Profile) {
		return fmt.Errorf("Profile this(%v) Not Equal that(%v)", this.Profile, that1.Profile)
	}
	if !this.LookupParameters.Equal(that1.LookupParameters) {
		return fmt.Errorf("LookupParameters this(%v) Not Equal that(%v)", this.LookupParameters, that1.LookupParameters)
	}
	if this.UserID != that1.UserID {
		return fmt.Errorf("UserID this(%v) Not Equal that(%v)", this.UserID, that1.UserID)
	}
	if !bytes.Equal(this.DKIMProof, that1.DKIMProof) {
		return fmt.Errorf("DKIMProof this(%v) Not Equal that(%v)", this.DKIMProof, that1.DKIMProof)
	}
	return nil
}
func (this *UpdateRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateRequest)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Update.Equal(that1.Update) {
		return false
	}
	if !this.Profile.Equal(that1.Profile) {
		return false
	}
	if !this.LookupParameters.Equal(that1.LookupParameters) {
		return false
	}
	if this.UserID != that1.UserID {
		return false
	}
	if !bytes.Equal(this.DKIMProof, that1.DKIMProof) {
		return false
	}
	return true
}
func (this *LookupProof) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LookupProof)
	if !ok {
		return fmt.Errorf("that is not of type *LookupProof")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LookupProof but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LookupProofbut is not nil && this == nil")
	}
	if this.UserId != that1.UserId {
		return fmt.Errorf("UserId this(%v) Not Equal that(%v)", this.UserId, that1.UserId)
	}
	if !bytes.Equal(this.IndexProof, that1.IndexProof) {
		return fmt.Errorf("IndexProof this(%v) Not Equal that(%v)", this.IndexProof, that1.IndexProof)
	}
	if len(this.Ratifications) != len(that1.Ratifications) {
		return fmt.Errorf("Ratifications this(%v) Not Equal that(%v)", len(this.Ratifications), len(that1.Ratifications))
	}
	for i := range this.Ratifications {
		if !this.Ratifications[i].Equal(that1.Ratifications[i]) {
			return fmt.Errorf("Ratifications this[%v](%v) Not Equal that[%v](%v)", i, this.Ratifications[i], i, that1.Ratifications[i])
		}
	}
	if !this.TreeProof.Equal(that1.TreeProof) {
		return fmt.Errorf("TreeProof this(%v) Not Equal that(%v)", this.TreeProof, that1.TreeProof)
	}
	if !this.Entry.Equal(that1.Entry) {
		return fmt.Errorf("Entry this(%v) Not Equal that(%v)", this.Entry, that1.Entry)
	}
	if !this.Profile.Equal(that1.Profile) {
		return fmt.Errorf("Profile this(%v) Not Equal that(%v)", this.Profile, that1.Profile)
	}
	return nil
}
func (this *LookupProof) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LookupProof)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if !bytes.Equal(this.IndexProof, that1.IndexProof) {
		return false
	}
	if len(this.Ratifications) != len(that1.Ratifications) {
		return false
	}
	for i := range this.Ratifications {
		if !this.Ratifications[i].Equal(that1.Ratifications[i]) {
			return false
		}
	}
	if !this.TreeProof.Equal(that1.TreeProof) {
		return false
	}
	if !this.Entry.Equal(that1.Entry) {
		return false
	}
	if !this.Profile.Equal(that1.Profile) {
		return false
	}
	return true
}
func (this *TreeProof) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TreeProof)
	if !ok {
		return fmt.Errorf("that is not of type *TreeProof")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TreeProof but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TreeProofbut is not nil && this == nil")
	}
	if len(this.Neighbors) != len(that1.Neighbors) {
		return fmt.Errorf("Neighbors this(%v) Not Equal that(%v)", len(this.Neighbors), len(that1.Neighbors))
	}
	for i := range this.Neighbors {
		if !bytes.Equal(this.Neighbors[i], that1.Neighbors[i]) {
			return fmt.Errorf("Neighbors this[%v](%v) Not Equal that[%v](%v)", i, this.Neighbors[i], i, that1.Neighbors[i])
		}
	}
	if !bytes.Equal(this.ExistingIndex, that1.ExistingIndex) {
		return fmt.Errorf("ExistingIndex this(%v) Not Equal that(%v)", this.ExistingIndex, that1.ExistingIndex)
	}
	if !bytes.Equal(this.ExistingEntryHash, that1.ExistingEntryHash) {
		return fmt.Errorf("ExistingEntryHash this(%v) Not Equal that(%v)", this.ExistingEntryHash, that1.ExistingEntryHash)
	}
	return nil
}
func (this *TreeProof) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeProof)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Neighbors) != len(that1.Neighbors) {
		return false
	}
	for i := range this.Neighbors {
		if !bytes.Equal(this.Neighbors[i], that1.Neighbors[i]) {
			return false
		}
	}
	if !bytes.Equal(this.ExistingIndex, that1.ExistingIndex) {
		return false
	}
	if !bytes.Equal(this.ExistingEntryHash, that1.ExistingEntryHash) {
		return false
	}
	return true
}
func (this *Entry) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Entry)
	if !ok {
		return fmt.Errorf("that is not of type *Entry")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Entry but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Entrybut is not nil && this == nil")
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return fmt.Errorf("Index this(%v) Not Equal that(%v)", this.Index, that1.Index)
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if !this.UpdatePolicy.Equal(that1.UpdatePolicy) {
		return fmt.Errorf("UpdatePolicy this(%v) Not Equal that(%v)", this.UpdatePolicy, that1.UpdatePolicy)
	}
	if !bytes.Equal(this.ProfileHash, that1.ProfileHash) {
		return fmt.Errorf("ProfileHash this(%v) Not Equal that(%v)", this.ProfileHash, that1.ProfileHash)
	}
	return nil
}
func (this *Entry) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Entry)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.UpdatePolicy.Equal(that1.UpdatePolicy) {
		return false
	}
	if !bytes.Equal(this.ProfileHash, that1.ProfileHash) {
		return false
	}
	return true
}
func (this *SignedEntryUpdate) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SignedEntryUpdate)
	if !ok {
		return fmt.Errorf("that is not of type *SignedEntryUpdate")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SignedEntryUpdate but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SignedEntryUpdatebut is not nil && this == nil")
	}
	if !this.NewEntry.Equal(that1.NewEntry) {
		return fmt.Errorf("NewEntry this(%v) Not Equal that(%v)", this.NewEntry, that1.NewEntry)
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return fmt.Errorf("Signatures this(%v) Not Equal that(%v)", len(this.Signatures), len(that1.Signatures))
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return fmt.Errorf("Signatures this[%v](%v) Not Equal that[%v](%v)", i, this.Signatures[i], i, that1.Signatures[i])
		}
	}
	return nil
}
func (this *SignedEntryUpdate) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SignedEntryUpdate)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.NewEntry.Equal(that1.NewEntry) {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return false
		}
	}
	return true
}
func (this *Profile) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Profile)
	if !ok {
		return fmt.Errorf("that is not of type *Profile")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Profile but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Profilebut is not nil && this == nil")
	}
	if !bytes.Equal(this.Nonce, that1.Nonce) {
		return fmt.Errorf("Nonce this(%v) Not Equal that(%v)", this.Nonce, that1.Nonce)
	}
	if len(this.Keys) != len(that1.Keys) {
		return fmt.Errorf("Keys this(%v) Not Equal that(%v)", len(this.Keys), len(that1.Keys))
	}
	for i := range this.Keys {
		if !bytes.Equal(this.Keys[i], that1.Keys[i]) {
			return fmt.Errorf("Keys this[%v](%v) Not Equal that[%v](%v)", i, this.Keys[i], i, that1.Keys[i])
		}
	}
	return nil
}
func (this *Profile) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Profile)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Nonce, that1.Nonce) {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if !bytes.Equal(this.Keys[i], that1.Keys[i]) {
			return false
		}
	}
	return true
}
func (this *SignedEpochHead) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SignedEpochHead)
	if !ok {
		return fmt.Errorf("that is not of type *SignedEpochHead")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SignedEpochHead but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SignedEpochHeadbut is not nil && this == nil")
	}
	if !this.Head.Equal(that1.Head) {
		return fmt.Errorf("Head this(%v) Not Equal that(%v)", this.Head, that1.Head)
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return fmt.Errorf("Signatures this(%v) Not Equal that(%v)", len(this.Signatures), len(that1.Signatures))
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return fmt.Errorf("Signatures this[%v](%v) Not Equal that[%v](%v)", i, this.Signatures[i], i, that1.Signatures[i])
		}
	}
	return nil
}
func (this *SignedEpochHead) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SignedEpochHead)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Head.Equal(that1.Head) {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return false
		}
	}
	return true
}
func (this *TimestampedEpochHead) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TimestampedEpochHead)
	if !ok {
		return fmt.Errorf("that is not of type *TimestampedEpochHead")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TimestampedEpochHead but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TimestampedEpochHeadbut is not nil && this == nil")
	}
	if !this.Head.Equal(that1.Head) {
		return fmt.Errorf("Head this(%v) Not Equal that(%v)", this.Head, that1.Head)
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	return nil
}
func (this *TimestampedEpochHead) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TimestampedEpochHead)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Head.Equal(that1.Head) {
		return false
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return false
	}
	return true
}
func (this *EpochHead) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*EpochHead)
	if !ok {
		return fmt.Errorf("that is not of type *EpochHead")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *EpochHead but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *EpochHeadbut is not nil && this == nil")
	}
	if this.Realm != that1.Realm {
		return fmt.Errorf("Realm this(%v) Not Equal that(%v)", this.Realm, that1.Realm)
	}
	if this.Epoch != that1.Epoch {
		return fmt.Errorf("Epoch this(%v) Not Equal that(%v)", this.Epoch, that1.Epoch)
	}
	if !bytes.Equal(this.RootHash, that1.RootHash) {
		return fmt.Errorf("RootHash this(%v) Not Equal that(%v)", this.RootHash, that1.RootHash)
	}
	if !bytes.Equal(this.PreviousSummaryHash, that1.PreviousSummaryHash) {
		return fmt.Errorf("PreviousSummaryHash this(%v) Not Equal that(%v)", this.PreviousSummaryHash, that1.PreviousSummaryHash)
	}
	if !this.NextEpochTime.Equal(&that1.NextEpochTime) {
		return fmt.Errorf("NextEpochTime this(%v) Not Equal that(%v)", this.NextEpochTime, that1.NextEpochTime)
	}
	if !this.NextEpochPolicy.Equal(&that1.NextEpochPolicy) {
		return fmt.Errorf("NextEpochPolicy this(%v) Not Equal that(%v)", this.NextEpochPolicy, that1.NextEpochPolicy)
	}
	return nil
}
func (this *EpochHead) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EpochHead)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Realm != that1.Realm {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if !bytes.Equal(this.RootHash, that1.RootHash) {
		return false
	}
	if !bytes.Equal(this.PreviousSummaryHash, that1.PreviousSummaryHash) {
		return false
	}
	if !this.NextEpochTime.Equal(&that1.NextEpochTime) {
		return false
	}
	if !this.NextEpochPolicy.Equal(&that1.NextEpochPolicy) {
		return false
	}
	return true
}
func (this *AuthorizationPolicy) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizationPolicy)
	if !ok {
		return fmt.Errorf("that is not of type *AuthorizationPolicy")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizationPolicy but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizationPolicybut is not nil && this == nil")
	}
	if len(this.PublicKeys) != len(that1.PublicKeys) {
		return fmt.Errorf("PublicKeys this(%v) Not Equal that(%v)", len(this.PublicKeys), len(that1.PublicKeys))
	}
	for i := range this.PublicKeys {
		if !this.PublicKeys[i].Equal(that1.PublicKeys[i]) {
			return fmt.Errorf("PublicKeys this[%v](%v) Not Equal that[%v](%v)", i, this.PublicKeys[i], i, that1.PublicKeys[i])
		}
	}
	if !this.Quorum.Equal(that1.Quorum) {
		return fmt.Errorf("Quorum this(%v) Not Equal that(%v)", this.Quorum, that1.Quorum)
	}
	return nil
}
func (this *AuthorizationPolicy) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AuthorizationPolicy)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.PublicKeys) != len(that1.PublicKeys) {
		return false
	}
	for i := range this.PublicKeys {
		if !this.PublicKeys[i].Equal(that1.PublicKeys[i]) {
			return false
		}
	}
	if !this.Quorum.Equal(that1.Quorum) {
		return false
	}
	return true
}
func (this *PublicKey) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PublicKey)
	if !ok {
		return fmt.Errorf("that is not of type *PublicKey")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PublicKey but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PublicKeybut is not nil && this == nil")
	}
	if !bytes.Equal(this.Ed25519, that1.Ed25519) {
		return fmt.Errorf("Ed25519 this(%v) Not Equal that(%v)", this.Ed25519, that1.Ed25519)
	}
	return nil
}
func (this *PublicKey) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PublicKey)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Ed25519, that1.Ed25519) {
		return false
	}
	return true
}
func (this *QuorumExpr) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*QuorumExpr)
	if !ok {
		return fmt.Errorf("that is not of type *QuorumExpr")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *QuorumExpr but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *QuorumExprbut is not nil && this == nil")
	}
	if this.Threshold != that1.Threshold {
		return fmt.Errorf("Threshold this(%v) Not Equal that(%v)", this.Threshold, that1.Threshold)
	}
	if len(this.Candidates) != len(that1.Candidates) {
		return fmt.Errorf("Candidates this(%v) Not Equal that(%v)", len(this.Candidates), len(that1.Candidates))
	}
	for i := range this.Candidates {
		if this.Candidates[i] != that1.Candidates[i] {
			return fmt.Errorf("Candidates this[%v](%v) Not Equal that[%v](%v)", i, this.Candidates[i], i, that1.Candidates[i])
		}
	}
	if len(this.Subexpressions) != len(that1.Subexpressions) {
		return fmt.Errorf("Subexpressions this(%v) Not Equal that(%v)", len(this.Subexpressions), len(that1.Subexpressions))
	}
	for i := range this.Subexpressions {
		if !this.Subexpressions[i].Equal(that1.Subexpressions[i]) {
			return fmt.Errorf("Subexpressions this[%v](%v) Not Equal that[%v](%v)", i, this.Subexpressions[i], i, that1.Subexpressions[i])
		}
	}
	return nil
}
func (this *QuorumExpr) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*QuorumExpr)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Threshold != that1.Threshold {
		return false
	}
	if len(this.Candidates) != len(that1.Candidates) {
		return false
	}
	for i := range this.Candidates {
		if this.Candidates[i] != that1.Candidates[i] {
			return false
		}
	}
	if len(this.Subexpressions) != len(that1.Subexpressions) {
		return false
	}
	for i := range this.Subexpressions {
		if !this.Subexpressions[i].Equal(that1.Subexpressions[i]) {
			return false
		}
	}
	return true
}
func (this *LookupRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.LookupRequest{` +
		`Epoch:` + fmt.Sprintf("%#v", this.Epoch),
		`UserId:` + fmt.Sprintf("%#v", this.UserId),
		`Index:` + fmt.Sprintf("%#v", this.Index),
		`QuorumRequirement:` + fmt.Sprintf("%#v", this.QuorumRequirement) + `}`}, ", ")
	return s
}
func (this *UpdateRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.UpdateRequest{` +
		`Update:` + fmt.Sprintf("%#v", this.Update),
		`Profile:` + strings.Replace(this.Profile.GoString(), `&`, ``, 1),
		`LookupParameters:` + fmt.Sprintf("%#v", this.LookupParameters),
		`UserID:` + fmt.Sprintf("%#v", this.UserID),
		`DKIMProof:` + fmt.Sprintf("%#v", this.DKIMProof) + `}`}, ", ")
	return s
}
func (this *LookupProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.LookupProof{` +
		`UserId:` + fmt.Sprintf("%#v", this.UserId),
		`IndexProof:` + fmt.Sprintf("%#v", this.IndexProof),
		`Ratifications:` + fmt.Sprintf("%#v", this.Ratifications),
		`TreeProof:` + fmt.Sprintf("%#v", this.TreeProof),
		`Entry:` + strings.Replace(this.Entry.GoString(), `&`, ``, 1),
		`Profile:` + strings.Replace(this.Profile.GoString(), `&`, ``, 1) + `}`}, ", ")
	return s
}
func (this *TreeProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.TreeProof{` +
		`Neighbors:` + fmt.Sprintf("%#v", this.Neighbors),
		`ExistingIndex:` + fmt.Sprintf("%#v", this.ExistingIndex),
		`ExistingEntryHash:` + fmt.Sprintf("%#v", this.ExistingEntryHash) + `}`}, ", ")
	return s
}
func (this *Entry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.Entry{` +
		`Index:` + fmt.Sprintf("%#v", this.Index),
		`Version:` + fmt.Sprintf("%#v", this.Version),
		`UpdatePolicy:` + fmt.Sprintf("%#v", this.UpdatePolicy),
		`ProfileHash:` + fmt.Sprintf("%#v", this.ProfileHash) + `}`}, ", ")
	return s
}
func (this *SignedEntryUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%#v: %#v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	s := strings.Join([]string{`&proto.SignedEntryUpdate{` +
		`NewEntry:` + strings.Replace(this.NewEntry.GoString(), `&`, ``, 1),
		`Signatures:` + mapStringForSignatures + `}`}, ", ")
	return s
}
func (this *Profile) GoString() string {
	if this == nil {
		return "nil"
	}
	keysForKeys := make([]string, 0, len(this.Keys))
	for k, _ := range this.Keys {
		keysForKeys = append(keysForKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Strings(keysForKeys)
	mapStringForKeys := "map[string][]byte{"
	for _, k := range keysForKeys {
		mapStringForKeys += fmt.Sprintf("%#v: %#v,", k, this.Keys[k])
	}
	mapStringForKeys += "}"
	s := strings.Join([]string{`&proto.Profile{` +
		`Nonce:` + fmt.Sprintf("%#v", this.Nonce),
		`Keys:` + mapStringForKeys + `}`}, ", ")
	return s
}
func (this *SignedEpochHead) GoString() string {
	if this == nil {
		return "nil"
	}
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%#v: %#v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	s := strings.Join([]string{`&proto.SignedEpochHead{` +
		`Head:` + strings.Replace(this.Head.GoString(), `&`, ``, 1),
		`Signatures:` + mapStringForSignatures + `}`}, ", ")
	return s
}
func (this *TimestampedEpochHead) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.TimestampedEpochHead{` +
		`Head:` + strings.Replace(this.Head.GoString(), `&`, ``, 1),
		`Timestamp:` + strings.Replace(this.Timestamp.GoString(), `&`, ``, 1) + `}`}, ", ")
	return s
}
func (this *EpochHead) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.EpochHead{` +
		`Realm:` + fmt.Sprintf("%#v", this.Realm),
		`Epoch:` + fmt.Sprintf("%#v", this.Epoch),
		`RootHash:` + fmt.Sprintf("%#v", this.RootHash),
		`PreviousSummaryHash:` + fmt.Sprintf("%#v", this.PreviousSummaryHash),
		`NextEpochTime:` + strings.Replace(this.NextEpochTime.GoString(), `&`, ``, 1),
		`NextEpochPolicy:` + strings.Replace(this.NextEpochPolicy.GoString(), `&`, ``, 1) + `}`}, ", ")
	return s
}
func (this *AuthorizationPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	keysForPublicKeys := make([]uint64, 0, len(this.PublicKeys))
	for k, _ := range this.PublicKeys {
		keysForPublicKeys = append(keysForPublicKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForPublicKeys)
	mapStringForPublicKeys := "map[uint64]*PublicKey{"
	for _, k := range keysForPublicKeys {
		mapStringForPublicKeys += fmt.Sprintf("%#v: %#v,", k, this.PublicKeys[k])
	}
	mapStringForPublicKeys += "}"
	s := strings.Join([]string{`&proto.AuthorizationPolicy{` +
		`PublicKeys:` + mapStringForPublicKeys,
		`Quorum:` + fmt.Sprintf("%#v", this.Quorum) + `}`}, ", ")
	return s
}
func (this *PublicKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.PublicKey{` +
		`Ed25519:` + fmt.Sprintf("%#v", this.Ed25519) + `}`}, ", ")
	return s
}
func (this *QuorumExpr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.QuorumExpr{` +
		`Threshold:` + fmt.Sprintf("%#v", this.Threshold),
		`Candidates:` + fmt.Sprintf("%#v", this.Candidates),
		`Subexpressions:` + fmt.Sprintf("%#v", this.Subexpressions) + `}`}, ", ")
	return s
}
func valueToGoStringClient(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringClient(e map[int32]github_com_andres_erbsen_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func (m *LookupRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintClient(data, i, uint64(m.Epoch))
	}
	if len(m.UserId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintClient(data, i, uint64(len(m.UserId)))
		i += copy(data[i:], m.UserId)
	}
	if m.Index != nil {
		if len(m.Index) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintClient(data, i, uint64(len(m.Index)))
			i += copy(data[i:], m.Index)
		}
	}
	if m.QuorumRequirement != nil {
		data[i] = 0x22
		i++
		i = encodeVarintClient(data, i, uint64(m.QuorumRequirement.Size()))
		n1, err := m.QuorumRequirement.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *UpdateRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UpdateRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Update != nil {
		data[i] = 0xa
		i++
		i = encodeVarintClient(data, i, uint64(m.Update.Size()))
		n2, err := m.Update.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	data[i] = 0x12
	i++
	i = encodeVarintClient(data, i, uint64(m.Profile.Size()))
	n3, err := m.Profile.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.LookupParameters != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintClient(data, i, uint64(m.LookupParameters.Size()))
		n4, err := m.LookupParameters.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.UserID) > 0 {
		data[i] = 0xc2
		i++
		data[i] = 0x3e
		i++
		i = encodeVarintClient(data, i, uint64(len(m.UserID)))
		i += copy(data[i:], m.UserID)
	}
	if m.DKIMProof != nil {
		if len(m.DKIMProof) > 0 {
			data[i] = 0xca
			i++
			data[i] = 0x3e
			i++
			i = encodeVarintClient(data, i, uint64(len(m.DKIMProof)))
			i += copy(data[i:], m.DKIMProof)
		}
	}
	return i, nil
}

func (m *LookupProof) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupProof) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintClient(data, i, uint64(len(m.UserId)))
		i += copy(data[i:], m.UserId)
	}
	if m.IndexProof != nil {
		if len(m.IndexProof) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(m.IndexProof)))
			i += copy(data[i:], m.IndexProof)
		}
	}
	if len(m.Ratifications) > 0 {
		for _, msg := range m.Ratifications {
			data[i] = 0x1a
			i++
			i = encodeVarintClient(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TreeProof != nil {
		data[i] = 0x22
		i++
		i = encodeVarintClient(data, i, uint64(m.TreeProof.Size()))
		n5, err := m.TreeProof.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	data[i] = 0x2a
	i++
	i = encodeVarintClient(data, i, uint64(m.Entry.Size()))
	n6, err := m.Entry.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	data[i] = 0x32
	i++
	i = encodeVarintClient(data, i, uint64(m.Profile.Size()))
	n7, err := m.Profile.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *TreeProof) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TreeProof) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Neighbors) > 0 {
		for _, b := range m.Neighbors {
			data[i] = 0xa
			i++
			i = encodeVarintClient(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if m.ExistingIndex != nil {
		if len(m.ExistingIndex) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(m.ExistingIndex)))
			i += copy(data[i:], m.ExistingIndex)
		}
	}
	if m.ExistingEntryHash != nil {
		if len(m.ExistingEntryHash) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintClient(data, i, uint64(len(m.ExistingEntryHash)))
			i += copy(data[i:], m.ExistingEntryHash)
		}
	}
	return i, nil
}

func (m *Entry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Entry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != nil {
		if len(m.Index) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintClient(data, i, uint64(len(m.Index)))
			i += copy(data[i:], m.Index)
		}
	}
	if m.Version != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintClient(data, i, uint64(m.Version))
	}
	if m.UpdatePolicy != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintClient(data, i, uint64(m.UpdatePolicy.Size()))
		n8, err := m.UpdatePolicy.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.ProfileHash != nil {
		if len(m.ProfileHash) > 0 {
			data[i] = 0x22
			i++
			i = encodeVarintClient(data, i, uint64(len(m.ProfileHash)))
			i += copy(data[i:], m.ProfileHash)
		}
	}
	return i, nil
}

func (m *SignedEntryUpdate) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SignedEntryUpdate) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintClient(data, i, uint64(m.NewEntry.Size()))
	n9, err := m.NewEntry.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.Signatures) > 0 {
		keysForSignatures := make([]uint64, 0, len(m.Signatures))
		for k, _ := range m.Signatures {
			keysForSignatures = append(keysForSignatures, k)
		}
		github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
		for _, k := range keysForSignatures {
			data[i] = 0x12
			i++
			v := m.Signatures[k]
			mapSize := 1 + 8 + 1 + len(v) + sovClient(uint64(len(v)))
			i = encodeVarintClient(data, i, uint64(mapSize))
			data[i] = 0x9
			i++
			i = encodeFixed64Client(data, i, uint64(k))
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *Profile) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Profile) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Nonce != nil {
		if len(m.Nonce) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintClient(data, i, uint64(len(m.Nonce)))
			i += copy(data[i:], m.Nonce)
		}
	}
	if len(m.Keys) > 0 {
		keysForKeys := make([]string, 0, len(m.Keys))
		for k, _ := range m.Keys {
			keysForKeys = append(keysForKeys, k)
		}
		github_com_andres_erbsen_protobuf_sortkeys.Strings(keysForKeys)
		for _, k := range keysForKeys {
			data[i] = 0x12
			i++
			v := m.Keys[k]
			mapSize := 1 + len(k) + sovClient(uint64(len(k))) + 1 + len(v) + sovClient(uint64(len(v)))
			i = encodeVarintClient(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintClient(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *SignedEpochHead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SignedEpochHead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintClient(data, i, uint64(m.Head.Size()))
	n10, err := m.Head.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.Signatures) > 0 {
		keysForSignatures := make([]uint64, 0, len(m.Signatures))
		for k, _ := range m.Signatures {
			keysForSignatures = append(keysForSignatures, k)
		}
		github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
		for _, k := range keysForSignatures {
			data[i] = 0x12
			i++
			v := m.Signatures[k]
			mapSize := 1 + 8 + 1 + len(v) + sovClient(uint64(len(v)))
			i = encodeVarintClient(data, i, uint64(mapSize))
			data[i] = 0x9
			i++
			i = encodeFixed64Client(data, i, uint64(k))
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *TimestampedEpochHead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TimestampedEpochHead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintClient(data, i, uint64(m.Head.Size()))
	n11, err := m.Head.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	data[i] = 0x12
	i++
	i = encodeVarintClient(data, i, uint64(m.Timestamp.Size()))
	n12, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *EpochHead) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EpochHead) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Realm) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintClient(data, i, uint64(len(m.Realm)))
		i += copy(data[i:], m.Realm)
	}
	if m.Epoch != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintClient(data, i, uint64(m.Epoch))
	}
	if m.RootHash != nil {
		if len(m.RootHash) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintClient(data, i, uint64(len(m.RootHash)))
			i += copy(data[i:], m.RootHash)
		}
	}
	if m.PreviousSummaryHash != nil {
		if len(m.PreviousSummaryHash) > 0 {
			data[i] = 0x22
			i++
			i = encodeVarintClient(data, i, uint64(len(m.PreviousSummaryHash)))
			i += copy(data[i:], m.PreviousSummaryHash)
		}
	}
	data[i] = 0x2a
	i++
	i = encodeVarintClient(data, i, uint64(m.NextEpochTime.Size()))
	n13, err := m.NextEpochTime.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	data[i] = 0x32
	i++
	i = encodeVarintClient(data, i, uint64(m.NextEpochPolicy.Size()))
	n14, err := m.NextEpochPolicy.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	return i, nil
}

func (m *AuthorizationPolicy) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuthorizationPolicy) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PublicKeys) > 0 {
		keysForPublicKeys := make([]uint64, 0, len(m.PublicKeys))
		for k, _ := range m.PublicKeys {
			keysForPublicKeys = append(keysForPublicKeys, k)
		}
		github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForPublicKeys)
		for _, k := range keysForPublicKeys {
			data[i] = 0xa
			i++
			v := m.PublicKeys[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + 8 + 1 + msgSize + sovClient(uint64(msgSize))
			i = encodeVarintClient(data, i, uint64(mapSize))
			data[i] = 0x9
			i++
			i = encodeFixed64Client(data, i, uint64(k))
			data[i] = 0x12
			i++
			i = encodeVarintClient(data, i, uint64(v.Size()))
			n15, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n15
		}
	}
	if m.Quorum != nil {
		data[i] = 0x12
		i++
		i = encodeVarintClient(data, i, uint64(m.Quorum.Size()))
		n16, err := m.Quorum.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *PublicKey) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PublicKey) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ed25519 != nil {
		if len(m.Ed25519) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintClient(data, i, uint64(len(m.Ed25519)))
			i += copy(data[i:], m.Ed25519)
		}
	}
	return i, nil
}

func (m *QuorumExpr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *QuorumExpr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Threshold != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintClient(data, i, uint64(m.Threshold))
	}
	if len(m.Candidates) > 0 {
		for _, num := range m.Candidates {
			data[i] = 0x11
			i++
			data[i] = uint8(num)
			i++
			data[i] = uint8(num >> 8)
			i++
			data[i] = uint8(num >> 16)
			i++
			data[i] = uint8(num >> 24)
			i++
			data[i] = uint8(num >> 32)
			i++
			data[i] = uint8(num >> 40)
			i++
			data[i] = uint8(num >> 48)
			i++
			data[i] = uint8(num >> 56)
			i++
		}
	}
	if len(m.Subexpressions) > 0 {
		for _, msg := range m.Subexpressions {
			data[i] = 0x1a
			i++
			i = encodeVarintClient(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Client(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Client(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintClient(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedLookupRequest(r randyClient, easy bool) *LookupRequest {
	this := &LookupRequest{}
	this.Epoch = uint64(uint64(r.Uint32()))
	this.UserId = randStringClient(r)
	v1 := r.Intn(100)
	this.Index = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.Index[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		this.QuorumRequirement = NewPopulatedQuorumExpr(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateRequest(r randyClient, easy bool) *UpdateRequest {
	this := &UpdateRequest{}
	if r.Intn(10) != 0 {
		this.Update = NewPopulatedSignedEntryUpdate(r, easy)
	}
	v2 := NewPopulatedProfile_PreserveEncoding(r, easy)
	this.Profile = *v2
	if r.Intn(10) != 0 {
		this.LookupParameters = NewPopulatedLookupRequest(r, easy)
	}
	this.UserID = randStringClient(r)
	v3 := r.Intn(100)
	this.DKIMProof = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.DKIMProof[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLookupProof(r randyClient, easy bool) *LookupProof {
	this := &LookupProof{}
	this.UserId = randStringClient(r)
	v4 := r.Intn(100)
	this.IndexProof = make([]byte, v4)
	for i := 0; i < v4; i++ {
		this.IndexProof[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(10)
		this.Ratifications = make([]*SignedEpochHead, v5)
		for i := 0; i < v5; i++ {
			this.Ratifications[i] = NewPopulatedSignedEpochHead(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.TreeProof = NewPopulatedTreeProof(r, easy)
	}
	v6 := NewPopulatedEntry_PreserveEncoding(r, easy)
	this.Entry = *v6
	v7 := NewPopulatedProfile_PreserveEncoding(r, easy)
	this.Profile = *v7
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTreeProof(r randyClient, easy bool) *TreeProof {
	this := &TreeProof{}
	v8 := r.Intn(100)
	this.Neighbors = make([][]byte, v8)
	for i := 0; i < v8; i++ {
		v9 := r.Intn(100)
		this.Neighbors[i] = make([]byte, v9)
		for j := 0; j < v9; j++ {
			this.Neighbors[i][j] = byte(r.Intn(256))
		}
	}
	v10 := r.Intn(100)
	this.ExistingIndex = make([]byte, v10)
	for i := 0; i < v10; i++ {
		this.ExistingIndex[i] = byte(r.Intn(256))
	}
	v11 := r.Intn(100)
	this.ExistingEntryHash = make([]byte, v11)
	for i := 0; i < v11; i++ {
		this.ExistingEntryHash[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEntry(r randyClient, easy bool) *Entry {
	this := &Entry{}
	v12 := r.Intn(100)
	this.Index = make([]byte, v12)
	for i := 0; i < v12; i++ {
		this.Index[i] = byte(r.Intn(256))
	}
	this.Version = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		this.UpdatePolicy = NewPopulatedAuthorizationPolicy(r, easy)
	}
	v13 := r.Intn(100)
	this.ProfileHash = make([]byte, v13)
	for i := 0; i < v13; i++ {
		this.ProfileHash[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSignedEntryUpdate(r randyClient, easy bool) *SignedEntryUpdate {
	this := &SignedEntryUpdate{}
	v14 := NewPopulatedEntry_PreserveEncoding(r, easy)
	this.NewEntry = *v14
	if r.Intn(10) != 0 {
		v15 := r.Intn(10)
		this.Signatures = make(map[uint64][]byte)
		for i := 0; i < v15; i++ {
			v16 := r.Intn(100)
			v17 := uint64(uint64(r.Uint32()))
			this.Signatures[v17] = make([]byte, v16)
			for i := 0; i < v16; i++ {
				this.Signatures[v17][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProfile(r randyClient, easy bool) *Profile {
	this := &Profile{}
	v18 := r.Intn(100)
	this.Nonce = make([]byte, v18)
	for i := 0; i < v18; i++ {
		this.Nonce[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v19 := r.Intn(10)
		this.Keys = make(map[string][]byte)
		for i := 0; i < v19; i++ {
			v20 := r.Intn(100)
			v21 := randStringClient(r)
			this.Keys[v21] = make([]byte, v20)
			for i := 0; i < v20; i++ {
				this.Keys[v21][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSignedEpochHead(r randyClient, easy bool) *SignedEpochHead {
	this := &SignedEpochHead{}
	v22 := NewPopulatedTimestampedEpochHead_PreserveEncoding(r, easy)
	this.Head = *v22
	if r.Intn(10) != 0 {
		v23 := r.Intn(10)
		this.Signatures = make(map[uint64][]byte)
		for i := 0; i < v23; i++ {
			v24 := r.Intn(100)
			v25 := uint64(uint64(r.Uint32()))
			this.Signatures[v25] = make([]byte, v24)
			for i := 0; i < v24; i++ {
				this.Signatures[v25][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTimestampedEpochHead(r randyClient, easy bool) *TimestampedEpochHead {
	this := &TimestampedEpochHead{}
	v26 := NewPopulatedEpochHead_PreserveEncoding(r, easy)
	this.Head = *v26
	v27 := NewPopulatedTimestamp(r, easy)
	this.Timestamp = *v27
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEpochHead(r randyClient, easy bool) *EpochHead {
	this := &EpochHead{}
	this.Realm = randStringClient(r)
	this.Epoch = uint64(uint64(r.Uint32()))
	v28 := r.Intn(100)
	this.RootHash = make([]byte, v28)
	for i := 0; i < v28; i++ {
		this.RootHash[i] = byte(r.Intn(256))
	}
	v29 := r.Intn(100)
	this.PreviousSummaryHash = make([]byte, v29)
	for i := 0; i < v29; i++ {
		this.PreviousSummaryHash[i] = byte(r.Intn(256))
	}
	v30 := NewPopulatedTimestamp(r, easy)
	this.NextEpochTime = *v30
	v31 := NewPopulatedAuthorizationPolicy(r, easy)
	this.NextEpochPolicy = *v31
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAuthorizationPolicy(r randyClient, easy bool) *AuthorizationPolicy {
	this := &AuthorizationPolicy{}
	if r.Intn(10) != 0 {
		v32 := r.Intn(10)
		this.PublicKeys = make(map[uint64]*PublicKey)
		for i := 0; i < v32; i++ {
			this.PublicKeys[uint64(uint64(r.Uint32()))] = NewPopulatedPublicKey(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Quorum = NewPopulatedQuorumExpr(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPublicKey(r randyClient, easy bool) *PublicKey {
	this := &PublicKey{}
	v33 := r.Intn(100)
	this.Ed25519 = make([]byte, v33)
	for i := 0; i < v33; i++ {
		this.Ed25519[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedQuorumExpr(r randyClient, easy bool) *QuorumExpr {
	this := &QuorumExpr{}
	this.Threshold = uint32(r.Uint32())
	v34 := r.Intn(100)
	this.Candidates = make([]uint64, v34)
	for i := 0; i < v34; i++ {
		this.Candidates[i] = uint64(uint64(r.Uint32()))
	}
	if r.Intn(10) != 0 {
		v35 := r.Intn(2)
		this.Subexpressions = make([]*QuorumExpr, v35)
		for i := 0; i < v35; i++ {
			this.Subexpressions[i] = NewPopulatedQuorumExpr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyClient interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneClient(r randyClient) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringClient(r randyClient) string {
	v36 := r.Intn(100)
	tmps := make([]rune, v36)
	for i := 0; i < v36; i++ {
		tmps[i] = randUTF8RuneClient(r)
	}
	return string(tmps)
}
func randUnrecognizedClient(r randyClient, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldClient(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldClient(data []byte, r randyClient, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateClient(data, uint64(key))
		v37 := r.Int63()
		if r.Intn(2) == 0 {
			v37 *= -1
		}
		data = encodeVarintPopulateClient(data, uint64(v37))
	case 1:
		data = encodeVarintPopulateClient(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateClient(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateClient(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateClient(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateClient(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *LookupRequest) Size() (n int) {
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovClient(uint64(m.Epoch))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	if m.Index != nil {
		l = len(m.Index)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.QuorumRequirement != nil {
		l = m.QuorumRequirement.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	return n
}

func (m *UpdateRequest) Size() (n int) {
	var l int
	_ = l
	if m.Update != nil {
		l = m.Update.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	l = m.Profile.Size()
	n += 1 + l + sovClient(uint64(l))
	if m.LookupParameters != nil {
		l = m.LookupParameters.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	l = len(m.UserID)
	if l > 0 {
		n += 2 + l + sovClient(uint64(l))
	}
	if m.DKIMProof != nil {
		l = len(m.DKIMProof)
		if l > 0 {
			n += 2 + l + sovClient(uint64(l))
		}
	}
	return n
}

func (m *LookupProof) Size() (n int) {
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	if m.IndexProof != nil {
		l = len(m.IndexProof)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if len(m.Ratifications) > 0 {
		for _, e := range m.Ratifications {
			l = e.Size()
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.TreeProof != nil {
		l = m.TreeProof.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	l = m.Entry.Size()
	n += 1 + l + sovClient(uint64(l))
	l = m.Profile.Size()
	n += 1 + l + sovClient(uint64(l))
	return n
}

func (m *TreeProof) Size() (n int) {
	var l int
	_ = l
	if len(m.Neighbors) > 0 {
		for _, b := range m.Neighbors {
			l = len(b)
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.ExistingIndex != nil {
		l = len(m.ExistingIndex)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.ExistingEntryHash != nil {
		l = len(m.ExistingEntryHash)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	return n
}

func (m *Entry) Size() (n int) {
	var l int
	_ = l
	if m.Index != nil {
		l = len(m.Index)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 1 + sovClient(uint64(m.Version))
	}
	if m.UpdatePolicy != nil {
		l = m.UpdatePolicy.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	if m.ProfileHash != nil {
		l = len(m.ProfileHash)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	return n
}

func (m *SignedEntryUpdate) Size() (n int) {
	var l int
	_ = l
	l = m.NewEntry.Size()
	n += 1 + l + sovClient(uint64(l))
	if len(m.Signatures) > 0 {
		for k, v := range m.Signatures {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + len(v) + sovClient(uint64(len(v)))
			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Profile) Size() (n int) {
	var l int
	_ = l
	if m.Nonce != nil {
		l = len(m.Nonce)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if len(m.Keys) > 0 {
		for k, v := range m.Keys {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovClient(uint64(len(k))) + 1 + len(v) + sovClient(uint64(len(v)))
			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SignedEpochHead) Size() (n int) {
	var l int
	_ = l
	l = m.Head.Size()
	n += 1 + l + sovClient(uint64(l))
	if len(m.Signatures) > 0 {
		for k, v := range m.Signatures {
			_ = k
			_ = v
			mapEntrySize := 1 + 8 + 1 + len(v) + sovClient(uint64(len(v)))
			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TimestampedEpochHead) Size() (n int) {
	var l int
	_ = l
	l = m.Head.Size()
	n += 1 + l + sovClient(uint64(l))
	l = m.Timestamp.Size()
	n += 1 + l + sovClient(uint64(l))
	return n
}

func (m *EpochHead) Size() (n int) {
	var l int
	_ = l
	l = len(m.Realm)
	if l > 0 {
		n += 1 + l + sovClient(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovClient(uint64(m.Epoch))
	}
	if m.RootHash != nil {
		l = len(m.RootHash)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	if m.PreviousSummaryHash != nil {
		l = len(m.PreviousSummaryHash)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	l = m.NextEpochTime.Size()
	n += 1 + l + sovClient(uint64(l))
	l = m.NextEpochPolicy.Size()
	n += 1 + l + sovClient(uint64(l))
	return n
}

func (m *AuthorizationPolicy) Size() (n int) {
	var l int
	_ = l
	if len(m.PublicKeys) > 0 {
		for k, v := range m.PublicKeys {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + 8 + 1 + l + sovClient(uint64(l))
			n += mapEntrySize + 1 + sovClient(uint64(mapEntrySize))
		}
	}
	if m.Quorum != nil {
		l = m.Quorum.Size()
		n += 1 + l + sovClient(uint64(l))
	}
	return n
}

func (m *PublicKey) Size() (n int) {
	var l int
	_ = l
	if m.Ed25519 != nil {
		l = len(m.Ed25519)
		if l > 0 {
			n += 1 + l + sovClient(uint64(l))
		}
	}
	return n
}

func (m *QuorumExpr) Size() (n int) {
	var l int
	_ = l
	if m.Threshold != 0 {
		n += 1 + sovClient(uint64(m.Threshold))
	}
	if len(m.Candidates) > 0 {
		n += 9 * len(m.Candidates)
	}
	if len(m.Subexpressions) > 0 {
		for _, e := range m.Subexpressions {
			l = e.Size()
			n += 1 + l + sovClient(uint64(l))
		}
	}
	return n
}

func sovClient(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozClient(x uint64) (n int) {
	return sovClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *LookupRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LookupRequest{`,
		`Epoch:` + fmt.Sprintf("%v", this.Epoch) + `,`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`QuorumRequirement:` + strings.Replace(fmt.Sprintf("%v", this.QuorumRequirement), "QuorumExpr", "QuorumExpr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateRequest{`,
		`Update:` + strings.Replace(fmt.Sprintf("%v", this.Update), "SignedEntryUpdate", "SignedEntryUpdate", 1) + `,`,
		`Profile:` + strings.Replace(strings.Replace(this.Profile.String(), "Profile", "Profile", 1), `&`, ``, 1) + `,`,
		`LookupParameters:` + strings.Replace(fmt.Sprintf("%v", this.LookupParameters), "LookupRequest", "LookupRequest", 1) + `,`,
		`UserID:` + fmt.Sprintf("%v", this.UserID) + `,`,
		`DKIMProof:` + fmt.Sprintf("%v", this.DKIMProof) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LookupProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LookupProof{`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`IndexProof:` + fmt.Sprintf("%v", this.IndexProof) + `,`,
		`Ratifications:` + strings.Replace(fmt.Sprintf("%v", this.Ratifications), "SignedEpochHead", "SignedEpochHead", 1) + `,`,
		`TreeProof:` + strings.Replace(fmt.Sprintf("%v", this.TreeProof), "TreeProof", "TreeProof", 1) + `,`,
		`Entry:` + strings.Replace(strings.Replace(this.Entry.String(), "Entry", "Entry", 1), `&`, ``, 1) + `,`,
		`Profile:` + strings.Replace(strings.Replace(this.Profile.String(), "Profile", "Profile", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreeProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeProof{`,
		`Neighbors:` + fmt.Sprintf("%v", this.Neighbors) + `,`,
		`ExistingIndex:` + fmt.Sprintf("%v", this.ExistingIndex) + `,`,
		`ExistingEntryHash:` + fmt.Sprintf("%v", this.ExistingEntryHash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Entry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Entry{`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`UpdatePolicy:` + strings.Replace(fmt.Sprintf("%v", this.UpdatePolicy), "AuthorizationPolicy", "AuthorizationPolicy", 1) + `,`,
		`ProfileHash:` + fmt.Sprintf("%v", this.ProfileHash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedEntryUpdate) String() string {
	if this == nil {
		return "nil"
	}
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%v: %v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	s := strings.Join([]string{`&SignedEntryUpdate{`,
		`NewEntry:` + strings.Replace(strings.Replace(this.NewEntry.String(), "Entry", "Entry", 1), `&`, ``, 1) + `,`,
		`Signatures:` + mapStringForSignatures + `,`,
		`}`,
	}, "")
	return s
}
func (this *Profile) String() string {
	if this == nil {
		return "nil"
	}
	keysForKeys := make([]string, 0, len(this.Keys))
	for k, _ := range this.Keys {
		keysForKeys = append(keysForKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Strings(keysForKeys)
	mapStringForKeys := "map[string][]byte{"
	for _, k := range keysForKeys {
		mapStringForKeys += fmt.Sprintf("%v: %v,", k, this.Keys[k])
	}
	mapStringForKeys += "}"
	s := strings.Join([]string{`&Profile{`,
		`Nonce:` + fmt.Sprintf("%v", this.Nonce) + `,`,
		`Keys:` + mapStringForKeys + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedEpochHead) String() string {
	if this == nil {
		return "nil"
	}
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%v: %v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	s := strings.Join([]string{`&SignedEpochHead{`,
		`Head:` + strings.Replace(strings.Replace(this.Head.String(), "TimestampedEpochHead", "TimestampedEpochHead", 1), `&`, ``, 1) + `,`,
		`Signatures:` + mapStringForSignatures + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimestampedEpochHead) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TimestampedEpochHead{`,
		`Head:` + strings.Replace(strings.Replace(this.Head.String(), "EpochHead", "EpochHead", 1), `&`, ``, 1) + `,`,
		`Timestamp:` + strings.Replace(strings.Replace(this.Timestamp.String(), "Timestamp", "Timestamp", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EpochHead) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EpochHead{`,
		`Realm:` + fmt.Sprintf("%v", this.Realm) + `,`,
		`Epoch:` + fmt.Sprintf("%v", this.Epoch) + `,`,
		`RootHash:` + fmt.Sprintf("%v", this.RootHash) + `,`,
		`PreviousSummaryHash:` + fmt.Sprintf("%v", this.PreviousSummaryHash) + `,`,
		`NextEpochTime:` + strings.Replace(strings.Replace(this.NextEpochTime.String(), "Timestamp", "Timestamp", 1), `&`, ``, 1) + `,`,
		`NextEpochPolicy:` + strings.Replace(strings.Replace(this.NextEpochPolicy.String(), "AuthorizationPolicy", "AuthorizationPolicy", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizationPolicy) String() string {
	if this == nil {
		return "nil"
	}
	keysForPublicKeys := make([]uint64, 0, len(this.PublicKeys))
	for k, _ := range this.PublicKeys {
		keysForPublicKeys = append(keysForPublicKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForPublicKeys)
	mapStringForPublicKeys := "map[uint64]*PublicKey{"
	for _, k := range keysForPublicKeys {
		mapStringForPublicKeys += fmt.Sprintf("%v: %v,", k, this.PublicKeys[k])
	}
	mapStringForPublicKeys += "}"
	s := strings.Join([]string{`&AuthorizationPolicy{`,
		`PublicKeys:` + mapStringForPublicKeys + `,`,
		`Quorum:` + strings.Replace(fmt.Sprintf("%v", this.Quorum), "QuorumExpr", "QuorumExpr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PublicKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PublicKey{`,
		`Ed25519:` + fmt.Sprintf("%v", this.Ed25519) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QuorumExpr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuorumExpr{`,
		`Threshold:` + fmt.Sprintf("%v", this.Threshold) + `,`,
		`Candidates:` + fmt.Sprintf("%v", this.Candidates) + `,`,
		`Subexpressions:` + strings.Replace(fmt.Sprintf("%v", this.Subexpressions), "QuorumExpr", "QuorumExpr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringClient(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *LookupRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Epoch |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumRequirement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuorumRequirement == nil {
				m.QuorumRequirement = &QuorumExpr{}
			}
			if err := m.QuorumRequirement.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *UpdateRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Update == nil {
				m.Update = &SignedEntryUpdate{}
			}
			if err := m.Update.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Profile.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LookupParameters == nil {
				m.LookupParameters = &LookupRequest{}
			}
			if err := m.LookupParameters.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DKIMProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DKIMProof = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *LookupProof) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexProof = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ratifications", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ratifications = append(m.Ratifications, &SignedEpochHead{})
			if err := m.Ratifications[len(m.Ratifications)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreeProof == nil {
				m.TreeProof = &TreeProof{}
			}
			if err := m.TreeProof.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Entry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Profile.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *TreeProof) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Neighbors", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Neighbors = append(m.Neighbors, make([]byte, postIndex-iNdEx))
			copy(m.Neighbors[len(m.Neighbors)-1], data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingIndex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExistingIndex = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingEntryHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExistingEntryHash = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *Entry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatePolicy == nil {
				m.UpdatePolicy = &AuthorizationPolicy{}
			}
			if err := m.UpdatePolicy.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileHash = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *SignedEntryUpdate) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewEntry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapkey = uint64(data[iNdEx-8])
			mapkey |= uint64(data[iNdEx-7]) << 8
			mapkey |= uint64(data[iNdEx-6]) << 16
			mapkey |= uint64(data[iNdEx-5]) << 24
			mapkey |= uint64(data[iNdEx-4]) << 32
			mapkey |= uint64(data[iNdEx-3]) << 40
			mapkey |= uint64(data[iNdEx-2]) << 48
			mapkey |= uint64(data[iNdEx-1]) << 56
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postbytesIndex := iNdEx + int(mapbyteLen)
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.Signatures == nil {
				m.Signatures = make(map[uint64][]byte)
			}
			m.Signatures[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *Profile) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postStringIndexmapkey := iNdEx + int(stringLenmapkey)
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postbytesIndex := iNdEx + int(mapbyteLen)
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.Keys == nil {
				m.Keys = make(map[string][]byte)
			}
			m.Keys[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *SignedEpochHead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Head.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapkey = uint64(data[iNdEx-8])
			mapkey |= uint64(data[iNdEx-7]) << 8
			mapkey |= uint64(data[iNdEx-6]) << 16
			mapkey |= uint64(data[iNdEx-5]) << 24
			mapkey |= uint64(data[iNdEx-4]) << 32
			mapkey |= uint64(data[iNdEx-3]) << 40
			mapkey |= uint64(data[iNdEx-2]) << 48
			mapkey |= uint64(data[iNdEx-1]) << 56
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postbytesIndex := iNdEx + int(mapbyteLen)
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.Signatures == nil {
				m.Signatures = make(map[uint64][]byte)
			}
			m.Signatures[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *TimestampedEpochHead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Head.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *EpochHead) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Realm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Realm = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Epoch |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootHash = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousSummaryHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousSummaryHash = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextEpochTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NextEpochTime.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextEpochPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NextEpochPolicy.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *AuthorizationPolicy) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			mapkey = uint64(data[iNdEx-8])
			mapkey |= uint64(data[iNdEx-7]) << 8
			mapkey |= uint64(data[iNdEx-6]) << 16
			mapkey |= uint64(data[iNdEx-5]) << 24
			mapkey |= uint64(data[iNdEx-4]) << 32
			mapkey |= uint64(data[iNdEx-3]) << 40
			mapkey |= uint64(data[iNdEx-2]) << 48
			mapkey |= uint64(data[iNdEx-1]) << 56
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthClient
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &PublicKey{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.PublicKeys == nil {
				m.PublicKeys = make(map[uint64]*PublicKey)
			}
			m.PublicKeys[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quorum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Quorum == nil {
				m.Quorum = &QuorumExpr{}
			}
			if err := m.Quorum.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *PublicKey) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ed25519", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthClient
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ed25519 = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func (m *QuorumExpr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Threshold |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Candidates", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Candidates = append(m.Candidates, v)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subexpressions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subexpressions = append(m.Subexpressions, &QuorumExpr{})
			if err := m.Subexpressions[len(m.Subexpressions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipClient(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	return nil
}
func skipClient(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthClient
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipClient(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthClient = fmt.Errorf("proto: negative length found during unmarshaling")
)
