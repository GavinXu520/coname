// Code generated by protoc-gen-gogo.
// source: client.proto
// DO NOT EDIT!

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	client.proto
	config.proto
	duration.proto
	keyserverconfig.proto
	keyserverlocal.proto
	replication.proto
	timestamp.proto
	tlsconfig.proto
	verifierconfig.proto
	verifierlocal.proto
	verifier.proto

It has these top-level messages:
	LookupRequest
	UpdateRequest
	LookupProof
	TreeProof
	Entry
	SignedEntryUpdate
	Profile
	SignedEpochHead
	TimestampedEpochHead
	EpochHead
	AuthorizationPolicy
	PublicKey
	QuorumExpr
*/
package proto

// discarding unused import gogoproto "gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import fmt "fmt"
import bytes "bytes"

import strings "strings"
import github_com_andres_erbsen_protobuf_proto "github.com/andres-erbsen/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"
import github_com_andres_erbsen_protobuf_sortkeys "github.com/andres-erbsen/protobuf/sortkeys"

type LookupRequest struct {
	// Epoch as of which to perform the lookup ("latest" if not specified)
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// UserId will be mapped to an index by the server using VRF
	UserId string `protobuf:"bytes,2,opt,name=user_id,proto3" json:"user_id,omitempty"`
	// quorum_requirement specifies which verifiers must have ratified the
	// result for it to be accepted. A server would fall back to an older
	// directory state if the ratifications of the latest one do not satisfy
	// the quorum requirement.
	QuorumRequirement *QuorumExpr `protobuf:"bytes,4,opt,name=quorum_requirement" json:"quorum_requirement,omitempty"`
}

func (m *LookupRequest) Reset()      { *m = LookupRequest{} }
func (*LookupRequest) ProtoMessage() {}

func (m *LookupRequest) GetQuorumRequirement() *QuorumExpr {
	if m != nil {
		return m.QuorumRequirement
	}
	return nil
}

// UpdateRequest specifies an update and the quorum required for
// considering the update successful. The server should respond with a lookup
// of the updated name with the specified parameters.
type UpdateRequest struct {
	// Update is passed on to verifiers.
	Update *SignedEntryUpdate `protobuf:"bytes,1,opt,name=update" json:"update,omitempty"`
	// Profile is included in the update request from the client to the
	// keyserver, but not passed on to the verifiers. The keyserver SHOULD
	// store it locally and include it in LookupProofs returned for lookups.
	// The verifiers MUST NOT try to read this field.
	// A keyserver MUST NOT discriminate users based on ther structure of their
	// profile other than enforcing a common-sense size limit. In particular, a
	// profile with fields that the keyserver does not understand or whose
	// values it considers invalid MUST be accepted.
	Profile          EncodedProfile `protobuf:"bytes,2,opt,name=profile,customtype=EncodedProfile" json:"profile"`
	LookupParameters *LookupRequest `protobuf:"bytes,3,opt,name=lookup_parameters" json:"lookup_parameters,omitempty"`
	DKIMProof        []byte         `protobuf:"bytes,1000,opt,name=dkim_proof,proto3" json:"dkim_proof,omitempty"`
}

func (m *UpdateRequest) Reset()      { *m = UpdateRequest{} }
func (*UpdateRequest) ProtoMessage() {}

func (m *UpdateRequest) GetUpdate() *SignedEntryUpdate {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *UpdateRequest) GetLookupParameters() *LookupRequest {
	if m != nil {
		return m.LookupParameters
	}
	return nil
}

// LookupProof encapsulates end-to-end cryptographc evidence that assuming *at
// least one* of the ratifiers has been correctly following the rules of the
// keyserver protocol then profile contains the latest public keys and metadata
// uploaded by user_id before the time specified in ratifications[0]. If any
// step of the proof does not check out, the contents of profile MUST NOT be
// used for any other purpose than debugging.
type LookupProof struct {
	UserId string `protobuf:"bytes,1,opt,name=user_id,proto3" json:"user_id,omitempty"`
	// index_proof proves that index is a result of applying a globally fixed
	// bijection VRF to user_id: idx = VRF(user_ID). If this proof checks out,
	// we can safely continue by looking up the keyserver entry corresponding
	// to index to get the public key of user_id.
	IndexProof []byte `protobuf:"bytes,2,opt,name=index_proof,proto3" json:"index_proof,omitempty"`
	// ratifications contains signed directory state summaries for the epoch under
	// which the lookup was performed.
	// A single valid ratification r by a honest and correct verifier implies
	// that the r.ratification.summary.root_hash summarizes the authenticated
	// data structure containing the unique and correct mapping from indices to
	// entries as of epoch r.ratification.epoch at human time
	// r.ratification.timestamp.
	// Each ratification must contain the same epoch head. A client MUST ignore a
	// proof if the ratifications do not satisfy its quorum requirement and MUST
	// require the keyserver itself to be in the quorum.
	Ratifications []*SignedEpochHead `protobuf:"bytes,3,rep,name=ratifications" json:"ratifications,omitempty"`
	// tree_proof contains an authenticated data structure lookup trace,
	// arguing that index maps to entry in the data structure with hash
	// ratifications[0].ratification.summary.root_hash.
	TreeProof *TreeProof `protobuf:"bytes,4,opt,name=tree_proof" json:"tree_proof,omitempty"`
	// Entry specifies profile by hash(profile) = entry.profile_hash
	Entry   EncodedEntry   `protobuf:"bytes,5,opt,name=entry,customtype=EncodedEntry" json:"entry"`
	Profile EncodedProfile `protobuf:"bytes,6,opt,name=profile,customtype=EncodedProfile" json:"profile"`
}

func (m *LookupProof) Reset()      { *m = LookupProof{} }
func (*LookupProof) ProtoMessage() {}

func (m *LookupProof) GetRatifications() []*SignedEpochHead {
	if m != nil {
		return m.Ratifications
	}
	return nil
}

func (m *LookupProof) GetTreeProof() *TreeProof {
	if m != nil {
		return m.TreeProof
	}
	return nil
}

// A Proof provides an authentication path through the Merkle Tree that
// proves that an item is or is not present in the tree.
type TreeProof struct {
	// Neighbors is a list of all the adjacent nodes along the path from the
	// bottommost node to the root. To save space, hashes for empty subtrees are
	// nil, and the number of hashes is equal to the length of the longest common
	// prefix with another entry in the tree (since a leaf node is moved up to
	// that point -- subtrees with a single entry are coalesced into a single
	// node).
	Neighbors [][]byte `protobuf:"bytes,1,rep,name=neighbors" json:"neighbors,omitempty"`
	// This is the index for the binding that does exist; it will share a prefix
	// with the requested index, but in case the leaf contains the wrong
	// contents, it will be different. It will be nil if the requested VRF falls
	// under an empty branch.
	ExistingIndex []byte `protobuf:"bytes,2,opt,name=existing_index,proto3" json:"existing_index,omitempty"`
	// This is the hash of the entry for the binding that does exist. If the leaf
	// contains the wrong contents, the client can use this to verify that the
	// incorrect leaf takes up the entire branch.
	ExistingEntryHash []byte `protobuf:"bytes,3,opt,name=existing_entry_hash,proto3" json:"existing_entry_hash,omitempty"`
}

func (m *TreeProof) Reset()      { *m = TreeProof{} }
func (*TreeProof) ProtoMessage() {}

// Entry is the value type in the authenticated mapping data structure.  The
// contents of all entries should be considered public (they are served to
// verifiers).
type Entry struct {
	// Index specifies the location of the entry in the authenticated
	// mapping data structure. It is computed as a verifiable random
	// function of the name: the keyserver can prove that index=vrf(name)
	// to anybody, but nobody else can compute vrf(name1). This is to
	// maintain the privacy of usernames.
	Index []byte `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	// Version starts at 0 at registration and must not decrease. The keyserver
	// and verifiers MUST reject SignedEntryUpdates which violate these rules.
	// The purpose of this is to prevent an attacker from replaying a
	// SignedEntryUpdate that publishes a key that the attacker has gained
	// control of. On the other hand, increases by more than one are allowed: a
	// user should be allowed to generate a long-lived offline revocation
	// certificate that is valid even after they make some other change to
	// their profile. Nevertheless, unless explicitly required otherwise,
	// clients should increase the version number by exactly one on each
	// update.
	Version uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// UpdatePolicy will be used to verify SignedEntryUpdates to this
	// entry. It is NOT used for encryption, and SHOULD be ignored by
	// applications that do not intend to manage the user's profile. It has
	// also been called "the public key of the profile signing key" or "the
	// public identity key". A keyserver MUST NOT discriminate users based on
	// ther structure of their update_key other than (1) as specified in
	// SignedEntryUpdate and (2) common-sense limits on the total size of an
	// entry to limit storage cost.
	UpdatePolicy *AuthorizationPolicy `protobuf:"bytes,3,opt,name=update_policy" json:"update_policy,omitempty"`
	// ProfileCommitment uniquely specifies the profile without revealing its
	// contents. The commitment is computed as commitment =
	// sha3shake256(profile); the contents contain a nonce.
	ProfileCommitment []byte `protobuf:"bytes,4,opt,name=profile_commitment,proto3" json:"profile_commitment,omitempty"`
}

func (m *Entry) Reset()      { *m = Entry{} }
func (*Entry) ProtoMessage() {}

func (m *Entry) GetUpdatePolicy() *AuthorizationPolicy {
	if m != nil {
		return m.UpdatePolicy
	}
	return nil
}

// SignedEntryUpdate is the minimal self-contained structure to justify
// changing the value of an entry. In the state machine model of a namespace,
// SignedEntryUpdate is the main input type.
type SignedEntryUpdate struct {
	NewEntry EncodedEntry `protobuf:"bytes,1,opt,name=new_entry,customtype=EncodedEntry" json:"new_entry"`
	// NewSig, if successfully verified using update.new_entry.update_key,
	// confirms that the new entry is willing to be bound to this index.
	// Both the keyserver and verifiers MUST check these signatures against the
	// old profile's authorization policy AND the new profile's authorization
	// policy. All signatures are tagged with ID of the public key that
	// generated them.
	Signatures map[uint64][]byte `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SignedEntryUpdate) Reset()      { *m = SignedEntryUpdate{} }
func (*SignedEntryUpdate) ProtoMessage() {}

func (m *SignedEntryUpdate) GetSignatures() map[uint64][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// A user's profile, containing public keys and other information.
// A new field will be added here for each application, with the TCP/UDP port
// number as field number whenever possible to avoid collisions.
type Profile struct {
	// Nonce containst at least 16 bytes (and counts towards the total profile
	// size limit). Having a nonce in each profile ensures that an attacker
	// can't guess-and-check somebody's profile contents using Entry.profile_hash.
	// It is the client's responsibility to generate a random nonce to protect the
	// privacy of its profile, thus the presence of this field is not checked by
	// the server.
	Nonce []byte `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Application-specific public keys. The map is keyed by application ID.
	Keys map[string][]byte `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Profile) Reset()      { *m = Profile{} }
func (*Profile) ProtoMessage() {}

func (m *Profile) GetKeys() map[string][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// SignedEpochHead messages are used by auditors and the service provider to
// vouch that the SummaryHash represents the correct unique global state at the
// end of epoch. In particular, it means that the signer has enforced the
// profile update policy specified in the doc-comments of SignedEntryUpdate and
// Profile for the specified epoch AND all prior epochs. A Ratification MUST
// NOT be signed in any other circumstances.
type SignedEpochHead struct {
	Head EncodedTimestampedEpochHead `protobuf:"bytes,1,opt,name=head,customtype=EncodedTimestampedEpochHead" json:"head"`
	// Signatures is used for authentication of ratification and MUST be
	// verified before interpreting any contents of ratification.
	// All signatures are tagged with ID of the public key that generated them.
	Signatures map[uint64][]byte `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SignedEpochHead) Reset()      { *m = SignedEpochHead{} }
func (*SignedEpochHead) ProtoMessage() {}

func (m *SignedEpochHead) GetSignatures() map[uint64][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type TimestampedEpochHead struct {
	// EpochHead specifies the entire state and history of the
	// realm.
	Head EncodedEpochHead `protobuf:"bytes,1,opt,name=head,customtype=EncodedEpochHead" json:"head"`
	// Timestamp specifies when the requirements for SignedEpochHead
	// were checked. Clients will accept a SignedEpochHead timestamped at most a
	// fixed amount of time into the past, and MUST fail secure if the timestamp
	// is not fresh because the directory state may have changed. The signature
	// expiration tolerance plus the maximum clock skew between a pair of clients
	// is the maximum propogation time of a change from one to another after which
	// even a malicious keyserver will not be able to convince a client to a
	// accept the previous state (assuming that all quorums the client considers
	// sufficient contain a correct and honest server).
	Timestamp Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
}

func (m *TimestampedEpochHead) Reset()      { *m = TimestampedEpochHead{} }
func (*TimestampedEpochHead) ProtoMessage() {}

func (m *TimestampedEpochHead) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

type EpochHead struct {
	// Realm is the fully-qualified domain name of the keyserver whose
	// state is being ratified.
	Realm string `protobuf:"bytes,1,opt,name=realm,proto3" json:"realm,omitempty"`
	// Epoch is a sequence number tracking distinct ratified states.
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// RootHash specifies the authenticated data structure.
	RootHash []byte `protobuf:"bytes,3,opt,name=root_hash,proto3" json:"root_hash,omitempty"`
	// IssueTime is the time when this epoch was released. All epochs for the
	// same keyserver MUST have non-decreasing IssueTimes.
	IssueTime Timestamp `protobuf:"bytes,4,opt,name=issue_time" json:"issue_time"`
	// PreviousSummaryHash chaining is used to allow signatures from
	// different epochs in the same quorum: a signature vouches for all
	// epochs chained to that in addition to the one listed.
	// Each PreviousSummaryHash depends on PreviousSummary, therefore
	// (by induction on the hash-pointer structure) a
	// PreviousSummeryHash for some epoch specifies the states of all
	// previous epochs. This hash uses SHA3-SHAKE256 with 64 bytes of output.
	PreviousSummaryHash []byte `protobuf:"bytes,5,opt,name=previous_summary_hash,proto3" json:"previous_summary_hash,omitempty"`
	// NextEpochPolicy allows for automated server key rollover: the new key(s)
	// are signed by the current one as a part of the epoch. This field is nil
	// if no key change is requested. If the server key is distributed with the
	// client software and benefits from reliable automated updates, clients
	// MAY ignore this field.
	NextEpochPolicy AuthorizationPolicy `protobuf:"bytes,6,opt,name=next_epoch_policy" json:"next_epoch_policy"`
}

func (m *EpochHead) Reset()      { *m = EpochHead{} }
func (*EpochHead) ProtoMessage() {}

func (m *EpochHead) GetIssueTime() Timestamp {
	if m != nil {
		return m.IssueTime
	}
	return Timestamp{}
}

func (m *EpochHead) GetNextEpochPolicy() AuthorizationPolicy {
	if m != nil {
		return m.NextEpochPolicy
	}
	return AuthorizationPolicy{}
}

// AuthorizationPolicy is used to check whether some signatures make up
// sufficient authorization to back an action.
// This is used to implement the following:
// 1. Account Recovery through service provider: if an user's entry has the
// update key set to threshold(1,user,serviceprovider), the service
// provider can perform account recovery. Note that a third party will not
// necessarily know who the subkeys are held by. Thus, the client
// implementation MUST require a signed certificate confirming possession
// of the secret key and promising to do no evil from every trustee whose
// key is used for recovery in this manner.
// 2. Service providers with servers in geographically diverse locations
// can use a threshold to limit the damage the compromise or loss of one
// replica can do. Example threshold(2,freedonia,gilead,mordor).
// 3. Adaptive key rollover during cryptocalypse.
type AuthorizationPolicy struct {
	PublicKeys map[uint64]*PublicKey `protobuf:"bytes,1,rep,name=public_keys" json:"public_keys,omitempty" protobuf_key:"fixed64,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Quorum     *QuorumExpr           `protobuf:"bytes,2,opt,name=quorum" json:"quorum,omitempty"`
}

func (m *AuthorizationPolicy) Reset()      { *m = AuthorizationPolicy{} }
func (*AuthorizationPolicy) ProtoMessage() {}

func (m *AuthorizationPolicy) GetPublicKeys() map[uint64]*PublicKey {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func (m *AuthorizationPolicy) GetQuorum() *QuorumExpr {
	if m != nil {
		return m.Quorum
	}
	return nil
}

// PublicKey wraps a public key of a cryptographically secure signature
// scheme and verification metadata. Each verifier can have its own signature
// format and needs to implement serialization and deserialization of its own
// signatures. The ID of a public key is defined as the 64-bit SHAKE256 hash of
// the protobuf-encoded public key (and interpreted as little-endian when a
// numeric representation is required).
type PublicKey struct {
	Ed25519 []byte `protobuf:"bytes,1,opt,name=ed25519,proto3" json:"ed25519,omitempty"`
}

func (m *PublicKey) Reset()      { *m = PublicKey{} }
func (*PublicKey) ProtoMessage() {}

// QuorumExpr represents a function with type set<uint64> -> bool. An
// expression evaluates to true given args iff the sum of the following two
// numbers is at least threshold:
// - number of entries in verifiers that are in args
// - number of subexpressions that evaluate to true
// note: expr.eval(a) \wedge expr.eval(b) -> expr.eval(a \cup b)
type QuorumExpr struct {
	Threshold  uint32   `protobuf:"varint,1,opt,name=threshold,proto3" json:"threshold,omitempty"`
	Candidates []uint64 `protobuf:"fixed64,2,rep,name=candidates" json:"candidates,omitempty"`
	// QuorumExpr allows expressing contitions of the form "two out of these
	// and three out of those".
	// If an implementation chooses to ban recursive thresholding, it can do so
	// ignoring this field. However, doing so is NOT SUPPORTED.
	Subexpressions []*QuorumExpr `protobuf:"bytes,3,rep,name=subexpressions" json:"subexpressions,omitempty"`
}

func (m *QuorumExpr) Reset()      { *m = QuorumExpr{} }
func (*QuorumExpr) ProtoMessage() {}

func (m *QuorumExpr) GetSubexpressions() []*QuorumExpr {
	if m != nil {
		return m.Subexpressions
	}
	return nil
}

// Client API for E2EKSPublic service

type E2EKSPublicClient interface {
	Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupProof, error)
	Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*LookupProof, error)
}

type e2EKSPublicClient struct {
	cc *grpc.ClientConn
}

func NewE2EKSPublicClient(cc *grpc.ClientConn) E2EKSPublicClient {
	return &e2EKSPublicClient{cc}
}

func (c *e2EKSPublicClient) Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupProof, error) {
	out := new(LookupProof)
	err := grpc.Invoke(ctx, "/proto.E2EKSPublic/Lookup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *e2EKSPublicClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*LookupProof, error) {
	out := new(LookupProof)
	err := grpc.Invoke(ctx, "/proto.E2EKSPublic/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for E2EKSPublic service

type E2EKSPublicServer interface {
	Lookup(context.Context, *LookupRequest) (*LookupProof, error)
	Update(context.Context, *UpdateRequest) (*LookupProof, error)
}

func RegisterE2EKSPublicServer(s *grpc.Server, srv E2EKSPublicServer) {
	s.RegisterService(&_E2EKSPublic_serviceDesc, srv)
}

func _E2EKSPublic_Lookup_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(LookupRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKSPublicServer).Lookup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _E2EKSPublic_Update_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(UpdateRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(E2EKSPublicServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _E2EKSPublic_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.E2EKSPublic",
	HandlerType: (*E2EKSPublicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Lookup",
			Handler:    _E2EKSPublic_Lookup_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _E2EKSPublic_Update_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (this *LookupRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LookupRequest)
	if !ok {
		return fmt.Errorf("that is not of type *LookupRequest")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LookupRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LookupRequestbut is not nil && this == nil")
	}
	if this.Epoch != that1.Epoch {
		return fmt.Errorf("Epoch this(%v) Not Equal that(%v)", this.Epoch, that1.Epoch)
	}
	if this.UserId != that1.UserId {
		return fmt.Errorf("UserId this(%v) Not Equal that(%v)", this.UserId, that1.UserId)
	}
	if !this.QuorumRequirement.Equal(that1.QuorumRequirement) {
		return fmt.Errorf("QuorumRequirement this(%v) Not Equal that(%v)", this.QuorumRequirement, that1.QuorumRequirement)
	}
	return nil
}
func (this *LookupRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LookupRequest)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if !this.QuorumRequirement.Equal(that1.QuorumRequirement) {
		return false
	}
	return true
}
func (this *UpdateRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*UpdateRequest)
	if !ok {
		return fmt.Errorf("that is not of type *UpdateRequest")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *UpdateRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *UpdateRequestbut is not nil && this == nil")
	}
	if !this.Update.Equal(that1.Update) {
		return fmt.Errorf("Update this(%v) Not Equal that(%v)", this.Update, that1.Update)
	}
	if !this.Profile.Equal(that1.Profile) {
		return fmt.Errorf("Profile this(%v) Not Equal that(%v)", this.Profile, that1.Profile)
	}
	if !this.LookupParameters.Equal(that1.LookupParameters) {
		return fmt.Errorf("LookupParameters this(%v) Not Equal that(%v)", this.LookupParameters, that1.LookupParameters)
	}
	if !bytes.Equal(this.DKIMProof, that1.DKIMProof) {
		return fmt.Errorf("DKIMProof this(%v) Not Equal that(%v)", this.DKIMProof, that1.DKIMProof)
	}
	return nil
}
func (this *UpdateRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UpdateRequest)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Update.Equal(that1.Update) {
		return false
	}
	if !this.Profile.Equal(that1.Profile) {
		return false
	}
	if !this.LookupParameters.Equal(that1.LookupParameters) {
		return false
	}
	if !bytes.Equal(this.DKIMProof, that1.DKIMProof) {
		return false
	}
	return true
}
func (this *LookupProof) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LookupProof)
	if !ok {
		return fmt.Errorf("that is not of type *LookupProof")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LookupProof but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LookupProofbut is not nil && this == nil")
	}
	if this.UserId != that1.UserId {
		return fmt.Errorf("UserId this(%v) Not Equal that(%v)", this.UserId, that1.UserId)
	}
	if !bytes.Equal(this.IndexProof, that1.IndexProof) {
		return fmt.Errorf("IndexProof this(%v) Not Equal that(%v)", this.IndexProof, that1.IndexProof)
	}
	if len(this.Ratifications) != len(that1.Ratifications) {
		return fmt.Errorf("Ratifications this(%v) Not Equal that(%v)", len(this.Ratifications), len(that1.Ratifications))
	}
	for i := range this.Ratifications {
		if !this.Ratifications[i].Equal(that1.Ratifications[i]) {
			return fmt.Errorf("Ratifications this[%v](%v) Not Equal that[%v](%v)", i, this.Ratifications[i], i, that1.Ratifications[i])
		}
	}
	if !this.TreeProof.Equal(that1.TreeProof) {
		return fmt.Errorf("TreeProof this(%v) Not Equal that(%v)", this.TreeProof, that1.TreeProof)
	}
	if !this.Entry.Equal(that1.Entry) {
		return fmt.Errorf("Entry this(%v) Not Equal that(%v)", this.Entry, that1.Entry)
	}
	if !this.Profile.Equal(that1.Profile) {
		return fmt.Errorf("Profile this(%v) Not Equal that(%v)", this.Profile, that1.Profile)
	}
	return nil
}
func (this *LookupProof) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LookupProof)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if !bytes.Equal(this.IndexProof, that1.IndexProof) {
		return false
	}
	if len(this.Ratifications) != len(that1.Ratifications) {
		return false
	}
	for i := range this.Ratifications {
		if !this.Ratifications[i].Equal(that1.Ratifications[i]) {
			return false
		}
	}
	if !this.TreeProof.Equal(that1.TreeProof) {
		return false
	}
	if !this.Entry.Equal(that1.Entry) {
		return false
	}
	if !this.Profile.Equal(that1.Profile) {
		return false
	}
	return true
}
func (this *TreeProof) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TreeProof)
	if !ok {
		return fmt.Errorf("that is not of type *TreeProof")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TreeProof but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TreeProofbut is not nil && this == nil")
	}
	if len(this.Neighbors) != len(that1.Neighbors) {
		return fmt.Errorf("Neighbors this(%v) Not Equal that(%v)", len(this.Neighbors), len(that1.Neighbors))
	}
	for i := range this.Neighbors {
		if !bytes.Equal(this.Neighbors[i], that1.Neighbors[i]) {
			return fmt.Errorf("Neighbors this[%v](%v) Not Equal that[%v](%v)", i, this.Neighbors[i], i, that1.Neighbors[i])
		}
	}
	if !bytes.Equal(this.ExistingIndex, that1.ExistingIndex) {
		return fmt.Errorf("ExistingIndex this(%v) Not Equal that(%v)", this.ExistingIndex, that1.ExistingIndex)
	}
	if !bytes.Equal(this.ExistingEntryHash, that1.ExistingEntryHash) {
		return fmt.Errorf("ExistingEntryHash this(%v) Not Equal that(%v)", this.ExistingEntryHash, that1.ExistingEntryHash)
	}
	return nil
}
func (this *TreeProof) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeProof)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Neighbors) != len(that1.Neighbors) {
		return false
	}
	for i := range this.Neighbors {
		if !bytes.Equal(this.Neighbors[i], that1.Neighbors[i]) {
			return false
		}
	}
	if !bytes.Equal(this.ExistingIndex, that1.ExistingIndex) {
		return false
	}
	if !bytes.Equal(this.ExistingEntryHash, that1.ExistingEntryHash) {
		return false
	}
	return true
}
func (this *Entry) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Entry)
	if !ok {
		return fmt.Errorf("that is not of type *Entry")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Entry but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Entrybut is not nil && this == nil")
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return fmt.Errorf("Index this(%v) Not Equal that(%v)", this.Index, that1.Index)
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if !this.UpdatePolicy.Equal(that1.UpdatePolicy) {
		return fmt.Errorf("UpdatePolicy this(%v) Not Equal that(%v)", this.UpdatePolicy, that1.UpdatePolicy)
	}
	if !bytes.Equal(this.ProfileCommitment, that1.ProfileCommitment) {
		return fmt.Errorf("ProfileCommitment this(%v) Not Equal that(%v)", this.ProfileCommitment, that1.ProfileCommitment)
	}
	return nil
}
func (this *Entry) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Entry)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Index, that1.Index) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.UpdatePolicy.Equal(that1.UpdatePolicy) {
		return false
	}
	if !bytes.Equal(this.ProfileCommitment, that1.ProfileCommitment) {
		return false
	}
	return true
}
func (this *SignedEntryUpdate) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SignedEntryUpdate)
	if !ok {
		return fmt.Errorf("that is not of type *SignedEntryUpdate")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SignedEntryUpdate but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SignedEntryUpdatebut is not nil && this == nil")
	}
	if !this.NewEntry.Equal(that1.NewEntry) {
		return fmt.Errorf("NewEntry this(%v) Not Equal that(%v)", this.NewEntry, that1.NewEntry)
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return fmt.Errorf("Signatures this(%v) Not Equal that(%v)", len(this.Signatures), len(that1.Signatures))
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return fmt.Errorf("Signatures this[%v](%v) Not Equal that[%v](%v)", i, this.Signatures[i], i, that1.Signatures[i])
		}
	}
	return nil
}
func (this *SignedEntryUpdate) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SignedEntryUpdate)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.NewEntry.Equal(that1.NewEntry) {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return false
		}
	}
	return true
}
func (this *Profile) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Profile)
	if !ok {
		return fmt.Errorf("that is not of type *Profile")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Profile but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Profilebut is not nil && this == nil")
	}
	if !bytes.Equal(this.Nonce, that1.Nonce) {
		return fmt.Errorf("Nonce this(%v) Not Equal that(%v)", this.Nonce, that1.Nonce)
	}
	if len(this.Keys) != len(that1.Keys) {
		return fmt.Errorf("Keys this(%v) Not Equal that(%v)", len(this.Keys), len(that1.Keys))
	}
	for i := range this.Keys {
		if !bytes.Equal(this.Keys[i], that1.Keys[i]) {
			return fmt.Errorf("Keys this[%v](%v) Not Equal that[%v](%v)", i, this.Keys[i], i, that1.Keys[i])
		}
	}
	return nil
}
func (this *Profile) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Profile)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Nonce, that1.Nonce) {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if !bytes.Equal(this.Keys[i], that1.Keys[i]) {
			return false
		}
	}
	return true
}
func (this *SignedEpochHead) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SignedEpochHead)
	if !ok {
		return fmt.Errorf("that is not of type *SignedEpochHead")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SignedEpochHead but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SignedEpochHeadbut is not nil && this == nil")
	}
	if !this.Head.Equal(that1.Head) {
		return fmt.Errorf("Head this(%v) Not Equal that(%v)", this.Head, that1.Head)
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return fmt.Errorf("Signatures this(%v) Not Equal that(%v)", len(this.Signatures), len(that1.Signatures))
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return fmt.Errorf("Signatures this[%v](%v) Not Equal that[%v](%v)", i, this.Signatures[i], i, that1.Signatures[i])
		}
	}
	return nil
}
func (this *SignedEpochHead) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SignedEpochHead)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Head.Equal(that1.Head) {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !bytes.Equal(this.Signatures[i], that1.Signatures[i]) {
			return false
		}
	}
	return true
}
func (this *TimestampedEpochHead) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TimestampedEpochHead)
	if !ok {
		return fmt.Errorf("that is not of type *TimestampedEpochHead")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TimestampedEpochHead but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TimestampedEpochHeadbut is not nil && this == nil")
	}
	if !this.Head.Equal(that1.Head) {
		return fmt.Errorf("Head this(%v) Not Equal that(%v)", this.Head, that1.Head)
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	return nil
}
func (this *TimestampedEpochHead) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TimestampedEpochHead)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Head.Equal(that1.Head) {
		return false
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return false
	}
	return true
}
func (this *EpochHead) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*EpochHead)
	if !ok {
		return fmt.Errorf("that is not of type *EpochHead")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *EpochHead but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *EpochHeadbut is not nil && this == nil")
	}
	if this.Realm != that1.Realm {
		return fmt.Errorf("Realm this(%v) Not Equal that(%v)", this.Realm, that1.Realm)
	}
	if this.Epoch != that1.Epoch {
		return fmt.Errorf("Epoch this(%v) Not Equal that(%v)", this.Epoch, that1.Epoch)
	}
	if !bytes.Equal(this.RootHash, that1.RootHash) {
		return fmt.Errorf("RootHash this(%v) Not Equal that(%v)", this.RootHash, that1.RootHash)
	}
	if !this.IssueTime.Equal(&that1.IssueTime) {
		return fmt.Errorf("IssueTime this(%v) Not Equal that(%v)", this.IssueTime, that1.IssueTime)
	}
	if !bytes.Equal(this.PreviousSummaryHash, that1.PreviousSummaryHash) {
		return fmt.Errorf("PreviousSummaryHash this(%v) Not Equal that(%v)", this.PreviousSummaryHash, that1.PreviousSummaryHash)
	}
	if !this.NextEpochPolicy.Equal(&that1.NextEpochPolicy) {
		return fmt.Errorf("NextEpochPolicy this(%v) Not Equal that(%v)", this.NextEpochPolicy, that1.NextEpochPolicy)
	}
	return nil
}
func (this *EpochHead) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EpochHead)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Realm != that1.Realm {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if !bytes.Equal(this.RootHash, that1.RootHash) {
		return false
	}
	if !this.IssueTime.Equal(&that1.IssueTime) {
		return false
	}
	if !bytes.Equal(this.PreviousSummaryHash, that1.PreviousSummaryHash) {
		return false
	}
	if !this.NextEpochPolicy.Equal(&that1.NextEpochPolicy) {
		return false
	}
	return true
}
func (this *AuthorizationPolicy) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AuthorizationPolicy)
	if !ok {
		return fmt.Errorf("that is not of type *AuthorizationPolicy")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AuthorizationPolicy but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AuthorizationPolicybut is not nil && this == nil")
	}
	if len(this.PublicKeys) != len(that1.PublicKeys) {
		return fmt.Errorf("PublicKeys this(%v) Not Equal that(%v)", len(this.PublicKeys), len(that1.PublicKeys))
	}
	for i := range this.PublicKeys {
		if !this.PublicKeys[i].Equal(that1.PublicKeys[i]) {
			return fmt.Errorf("PublicKeys this[%v](%v) Not Equal that[%v](%v)", i, this.PublicKeys[i], i, that1.PublicKeys[i])
		}
	}
	if !this.Quorum.Equal(that1.Quorum) {
		return fmt.Errorf("Quorum this(%v) Not Equal that(%v)", this.Quorum, that1.Quorum)
	}
	return nil
}
func (this *AuthorizationPolicy) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AuthorizationPolicy)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.PublicKeys) != len(that1.PublicKeys) {
		return false
	}
	for i := range this.PublicKeys {
		if !this.PublicKeys[i].Equal(that1.PublicKeys[i]) {
			return false
		}
	}
	if !this.Quorum.Equal(that1.Quorum) {
		return false
	}
	return true
}
func (this *PublicKey) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PublicKey)
	if !ok {
		return fmt.Errorf("that is not of type *PublicKey")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PublicKey but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PublicKeybut is not nil && this == nil")
	}
	if !bytes.Equal(this.Ed25519, that1.Ed25519) {
		return fmt.Errorf("Ed25519 this(%v) Not Equal that(%v)", this.Ed25519, that1.Ed25519)
	}
	return nil
}
func (this *PublicKey) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PublicKey)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Ed25519, that1.Ed25519) {
		return false
	}
	return true
}
func (this *QuorumExpr) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*QuorumExpr)
	if !ok {
		return fmt.Errorf("that is not of type *QuorumExpr")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *QuorumExpr but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *QuorumExprbut is not nil && this == nil")
	}
	if this.Threshold != that1.Threshold {
		return fmt.Errorf("Threshold this(%v) Not Equal that(%v)", this.Threshold, that1.Threshold)
	}
	if len(this.Candidates) != len(that1.Candidates) {
		return fmt.Errorf("Candidates this(%v) Not Equal that(%v)", len(this.Candidates), len(that1.Candidates))
	}
	for i := range this.Candidates {
		if this.Candidates[i] != that1.Candidates[i] {
			return fmt.Errorf("Candidates this[%v](%v) Not Equal that[%v](%v)", i, this.Candidates[i], i, that1.Candidates[i])
		}
	}
	if len(this.Subexpressions) != len(that1.Subexpressions) {
		return fmt.Errorf("Subexpressions this(%v) Not Equal that(%v)", len(this.Subexpressions), len(that1.Subexpressions))
	}
	for i := range this.Subexpressions {
		if !this.Subexpressions[i].Equal(that1.Subexpressions[i]) {
			return fmt.Errorf("Subexpressions this[%v](%v) Not Equal that[%v](%v)", i, this.Subexpressions[i], i, that1.Subexpressions[i])
		}
	}
	return nil
}
func (this *QuorumExpr) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*QuorumExpr)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Threshold != that1.Threshold {
		return false
	}
	if len(this.Candidates) != len(that1.Candidates) {
		return false
	}
	for i := range this.Candidates {
		if this.Candidates[i] != that1.Candidates[i] {
			return false
		}
	}
	if len(this.Subexpressions) != len(that1.Subexpressions) {
		return false
	}
	for i := range this.Subexpressions {
		if !this.Subexpressions[i].Equal(that1.Subexpressions[i]) {
			return false
		}
	}
	return true
}
func (this *LookupRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.LookupRequest{` +
		`Epoch:` + fmt.Sprintf("%#v", this.Epoch),
		`UserId:` + fmt.Sprintf("%#v", this.UserId),
		`QuorumRequirement:` + fmt.Sprintf("%#v", this.QuorumRequirement) + `}`}, ", ")
	return s
}
func (this *UpdateRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.UpdateRequest{` +
		`Update:` + fmt.Sprintf("%#v", this.Update),
		`Profile:` + strings.Replace(this.Profile.GoString(), `&`, ``, 1),
		`LookupParameters:` + fmt.Sprintf("%#v", this.LookupParameters),
		`DKIMProof:` + fmt.Sprintf("%#v", this.DKIMProof) + `}`}, ", ")
	return s
}
func (this *LookupProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.LookupProof{` +
		`UserId:` + fmt.Sprintf("%#v", this.UserId),
		`IndexProof:` + fmt.Sprintf("%#v", this.IndexProof),
		`Ratifications:` + fmt.Sprintf("%#v", this.Ratifications),
		`TreeProof:` + fmt.Sprintf("%#v", this.TreeProof),
		`Entry:` + strings.Replace(this.Entry.GoString(), `&`, ``, 1),
		`Profile:` + strings.Replace(this.Profile.GoString(), `&`, ``, 1) + `}`}, ", ")
	return s
}
func (this *TreeProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.TreeProof{` +
		`Neighbors:` + fmt.Sprintf("%#v", this.Neighbors),
		`ExistingIndex:` + fmt.Sprintf("%#v", this.ExistingIndex),
		`ExistingEntryHash:` + fmt.Sprintf("%#v", this.ExistingEntryHash) + `}`}, ", ")
	return s
}
func (this *Entry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.Entry{` +
		`Index:` + fmt.Sprintf("%#v", this.Index),
		`Version:` + fmt.Sprintf("%#v", this.Version),
		`UpdatePolicy:` + fmt.Sprintf("%#v", this.UpdatePolicy),
		`ProfileCommitment:` + fmt.Sprintf("%#v", this.ProfileCommitment) + `}`}, ", ")
	return s
}
func (this *SignedEntryUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%#v: %#v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	s := strings.Join([]string{`&proto.SignedEntryUpdate{` +
		`NewEntry:` + strings.Replace(this.NewEntry.GoString(), `&`, ``, 1),
		`Signatures:` + mapStringForSignatures + `}`}, ", ")
	return s
}
func (this *Profile) GoString() string {
	if this == nil {
		return "nil"
	}
	keysForKeys := make([]string, 0, len(this.Keys))
	for k, _ := range this.Keys {
		keysForKeys = append(keysForKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Strings(keysForKeys)
	mapStringForKeys := "map[string][]byte{"
	for _, k := range keysForKeys {
		mapStringForKeys += fmt.Sprintf("%#v: %#v,", k, this.Keys[k])
	}
	mapStringForKeys += "}"
	s := strings.Join([]string{`&proto.Profile{` +
		`Nonce:` + fmt.Sprintf("%#v", this.Nonce),
		`Keys:` + mapStringForKeys + `}`}, ", ")
	return s
}
func (this *SignedEpochHead) GoString() string {
	if this == nil {
		return "nil"
	}
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%#v: %#v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	s := strings.Join([]string{`&proto.SignedEpochHead{` +
		`Head:` + strings.Replace(this.Head.GoString(), `&`, ``, 1),
		`Signatures:` + mapStringForSignatures + `}`}, ", ")
	return s
}
func (this *TimestampedEpochHead) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.TimestampedEpochHead{` +
		`Head:` + strings.Replace(this.Head.GoString(), `&`, ``, 1),
		`Timestamp:` + strings.Replace(this.Timestamp.GoString(), `&`, ``, 1) + `}`}, ", ")
	return s
}
func (this *EpochHead) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.EpochHead{` +
		`Realm:` + fmt.Sprintf("%#v", this.Realm),
		`Epoch:` + fmt.Sprintf("%#v", this.Epoch),
		`RootHash:` + fmt.Sprintf("%#v", this.RootHash),
		`IssueTime:` + strings.Replace(this.IssueTime.GoString(), `&`, ``, 1),
		`PreviousSummaryHash:` + fmt.Sprintf("%#v", this.PreviousSummaryHash),
		`NextEpochPolicy:` + strings.Replace(this.NextEpochPolicy.GoString(), `&`, ``, 1) + `}`}, ", ")
	return s
}
func (this *AuthorizationPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	keysForPublicKeys := make([]uint64, 0, len(this.PublicKeys))
	for k, _ := range this.PublicKeys {
		keysForPublicKeys = append(keysForPublicKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForPublicKeys)
	mapStringForPublicKeys := "map[uint64]*PublicKey{"
	for _, k := range keysForPublicKeys {
		mapStringForPublicKeys += fmt.Sprintf("%#v: %#v,", k, this.PublicKeys[k])
	}
	mapStringForPublicKeys += "}"
	s := strings.Join([]string{`&proto.AuthorizationPolicy{` +
		`PublicKeys:` + mapStringForPublicKeys,
		`Quorum:` + fmt.Sprintf("%#v", this.Quorum) + `}`}, ", ")
	return s
}
func (this *PublicKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.PublicKey{` +
		`Ed25519:` + fmt.Sprintf("%#v", this.Ed25519) + `}`}, ", ")
	return s
}
func (this *QuorumExpr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&proto.QuorumExpr{` +
		`Threshold:` + fmt.Sprintf("%#v", this.Threshold),
		`Candidates:` + fmt.Sprintf("%#v", this.Candidates),
		`Subexpressions:` + fmt.Sprintf("%#v", this.Subexpressions) + `}`}, ", ")
	return s
}
func valueToGoStringClient(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringClient(e map[int32]github_com_andres_erbsen_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func NewPopulatedLookupRequest(r randyClient, easy bool) *LookupRequest {
	this := &LookupRequest{}
	this.Epoch = uint64(uint64(r.Uint32()))
	this.UserId = randStringClient(r)
	if r.Intn(10) != 0 {
		this.QuorumRequirement = NewPopulatedQuorumExpr(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedUpdateRequest(r randyClient, easy bool) *UpdateRequest {
	this := &UpdateRequest{}
	if r.Intn(10) != 0 {
		this.Update = NewPopulatedSignedEntryUpdate(r, easy)
	}
	v1 := NewPopulatedEncodedProfile(r, easy)
	this.Profile = *v1
	if r.Intn(10) != 0 {
		this.LookupParameters = NewPopulatedLookupRequest(r, easy)
	}
	v2 := r.Intn(100)
	this.DKIMProof = make([]byte, v2)
	for i := 0; i < v2; i++ {
		this.DKIMProof[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLookupProof(r randyClient, easy bool) *LookupProof {
	this := &LookupProof{}
	this.UserId = randStringClient(r)
	v3 := r.Intn(100)
	this.IndexProof = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.IndexProof[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v4 := r.Intn(10)
		this.Ratifications = make([]*SignedEpochHead, v4)
		for i := 0; i < v4; i++ {
			this.Ratifications[i] = NewPopulatedSignedEpochHead(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.TreeProof = NewPopulatedTreeProof(r, easy)
	}
	v5 := NewPopulatedEncodedEntry(r, easy)
	this.Entry = *v5
	v6 := NewPopulatedEncodedProfile(r, easy)
	this.Profile = *v6
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTreeProof(r randyClient, easy bool) *TreeProof {
	this := &TreeProof{}
	v7 := r.Intn(100)
	this.Neighbors = make([][]byte, v7)
	for i := 0; i < v7; i++ {
		v8 := r.Intn(100)
		this.Neighbors[i] = make([]byte, v8)
		for j := 0; j < v8; j++ {
			this.Neighbors[i][j] = byte(r.Intn(256))
		}
	}
	v9 := r.Intn(100)
	this.ExistingIndex = make([]byte, v9)
	for i := 0; i < v9; i++ {
		this.ExistingIndex[i] = byte(r.Intn(256))
	}
	v10 := r.Intn(100)
	this.ExistingEntryHash = make([]byte, v10)
	for i := 0; i < v10; i++ {
		this.ExistingEntryHash[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEntry(r randyClient, easy bool) *Entry {
	this := &Entry{}
	v11 := r.Intn(100)
	this.Index = make([]byte, v11)
	for i := 0; i < v11; i++ {
		this.Index[i] = byte(r.Intn(256))
	}
	this.Version = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		this.UpdatePolicy = NewPopulatedAuthorizationPolicy(r, easy)
	}
	v12 := r.Intn(100)
	this.ProfileCommitment = make([]byte, v12)
	for i := 0; i < v12; i++ {
		this.ProfileCommitment[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSignedEntryUpdate(r randyClient, easy bool) *SignedEntryUpdate {
	this := &SignedEntryUpdate{}
	v13 := NewPopulatedEncodedEntry(r, easy)
	this.NewEntry = *v13
	if r.Intn(10) != 0 {
		v14 := r.Intn(10)
		this.Signatures = make(map[uint64][]byte)
		for i := 0; i < v14; i++ {
			v15 := r.Intn(100)
			v16 := uint64(uint64(r.Uint32()))
			this.Signatures[v16] = make([]byte, v15)
			for i := 0; i < v15; i++ {
				this.Signatures[v16][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedProfile(r randyClient, easy bool) *Profile {
	this := &Profile{}
	v17 := r.Intn(100)
	this.Nonce = make([]byte, v17)
	for i := 0; i < v17; i++ {
		this.Nonce[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v18 := r.Intn(10)
		this.Keys = make(map[string][]byte)
		for i := 0; i < v18; i++ {
			v19 := r.Intn(100)
			v20 := randStringClient(r)
			this.Keys[v20] = make([]byte, v19)
			for i := 0; i < v19; i++ {
				this.Keys[v20][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSignedEpochHead(r randyClient, easy bool) *SignedEpochHead {
	this := &SignedEpochHead{}
	v21 := NewPopulatedEncodedTimestampedEpochHead(r, easy)
	this.Head = *v21
	if r.Intn(10) != 0 {
		v22 := r.Intn(10)
		this.Signatures = make(map[uint64][]byte)
		for i := 0; i < v22; i++ {
			v23 := r.Intn(100)
			v24 := uint64(uint64(r.Uint32()))
			this.Signatures[v24] = make([]byte, v23)
			for i := 0; i < v23; i++ {
				this.Signatures[v24][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTimestampedEpochHead(r randyClient, easy bool) *TimestampedEpochHead {
	this := &TimestampedEpochHead{}
	v25 := NewPopulatedEncodedEpochHead(r, easy)
	this.Head = *v25
	v26 := NewPopulatedTimestamp(r, easy)
	this.Timestamp = *v26
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEpochHead(r randyClient, easy bool) *EpochHead {
	this := &EpochHead{}
	this.Realm = randStringClient(r)
	this.Epoch = uint64(uint64(r.Uint32()))
	v27 := r.Intn(100)
	this.RootHash = make([]byte, v27)
	for i := 0; i < v27; i++ {
		this.RootHash[i] = byte(r.Intn(256))
	}
	v28 := NewPopulatedTimestamp(r, easy)
	this.IssueTime = *v28
	v29 := r.Intn(100)
	this.PreviousSummaryHash = make([]byte, v29)
	for i := 0; i < v29; i++ {
		this.PreviousSummaryHash[i] = byte(r.Intn(256))
	}
	v30 := NewPopulatedAuthorizationPolicy(r, easy)
	this.NextEpochPolicy = *v30
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAuthorizationPolicy(r randyClient, easy bool) *AuthorizationPolicy {
	this := &AuthorizationPolicy{}
	if r.Intn(10) != 0 {
		v31 := r.Intn(10)
		this.PublicKeys = make(map[uint64]*PublicKey)
		for i := 0; i < v31; i++ {
			this.PublicKeys[uint64(uint64(r.Uint32()))] = NewPopulatedPublicKey(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		this.Quorum = NewPopulatedQuorumExpr(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPublicKey(r randyClient, easy bool) *PublicKey {
	this := &PublicKey{}
	v32 := r.Intn(100)
	this.Ed25519 = make([]byte, v32)
	for i := 0; i < v32; i++ {
		this.Ed25519[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedQuorumExpr(r randyClient, easy bool) *QuorumExpr {
	this := &QuorumExpr{}
	this.Threshold = uint32(r.Uint32())
	v33 := r.Intn(100)
	this.Candidates = make([]uint64, v33)
	for i := 0; i < v33; i++ {
		this.Candidates[i] = uint64(uint64(r.Uint32()))
	}
	if r.Intn(10) != 0 {
		v34 := r.Intn(2)
		this.Subexpressions = make([]*QuorumExpr, v34)
		for i := 0; i < v34; i++ {
			this.Subexpressions[i] = NewPopulatedQuorumExpr(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyClient interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneClient(r randyClient) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringClient(r randyClient) string {
	v35 := r.Intn(100)
	tmps := make([]rune, v35)
	for i := 0; i < v35; i++ {
		tmps[i] = randUTF8RuneClient(r)
	}
	return string(tmps)
}
func randUnrecognizedClient(r randyClient, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldClient(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldClient(data []byte, r randyClient, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateClient(data, uint64(key))
		v36 := r.Int63()
		if r.Intn(2) == 0 {
			v36 *= -1
		}
		data = encodeVarintPopulateClient(data, uint64(v36))
	case 1:
		data = encodeVarintPopulateClient(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateClient(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateClient(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateClient(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateClient(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (this *LookupRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LookupRequest{`,
		`Epoch:` + fmt.Sprintf("%v", this.Epoch) + `,`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`QuorumRequirement:` + strings.Replace(fmt.Sprintf("%v", this.QuorumRequirement), "QuorumExpr", "QuorumExpr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateRequest{`,
		`Update:` + strings.Replace(fmt.Sprintf("%v", this.Update), "SignedEntryUpdate", "SignedEntryUpdate", 1) + `,`,
		`Profile:` + strings.Replace(strings.Replace(this.Profile.String(), "Profile", "Profile", 1), `&`, ``, 1) + `,`,
		`LookupParameters:` + strings.Replace(fmt.Sprintf("%v", this.LookupParameters), "LookupRequest", "LookupRequest", 1) + `,`,
		`DKIMProof:` + fmt.Sprintf("%v", this.DKIMProof) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LookupProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LookupProof{`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`IndexProof:` + fmt.Sprintf("%v", this.IndexProof) + `,`,
		`Ratifications:` + strings.Replace(fmt.Sprintf("%v", this.Ratifications), "SignedEpochHead", "SignedEpochHead", 1) + `,`,
		`TreeProof:` + strings.Replace(fmt.Sprintf("%v", this.TreeProof), "TreeProof", "TreeProof", 1) + `,`,
		`Entry:` + strings.Replace(strings.Replace(this.Entry.String(), "Entry", "Entry", 1), `&`, ``, 1) + `,`,
		`Profile:` + strings.Replace(strings.Replace(this.Profile.String(), "Profile", "Profile", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreeProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeProof{`,
		`Neighbors:` + fmt.Sprintf("%v", this.Neighbors) + `,`,
		`ExistingIndex:` + fmt.Sprintf("%v", this.ExistingIndex) + `,`,
		`ExistingEntryHash:` + fmt.Sprintf("%v", this.ExistingEntryHash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Entry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Entry{`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`UpdatePolicy:` + strings.Replace(fmt.Sprintf("%v", this.UpdatePolicy), "AuthorizationPolicy", "AuthorizationPolicy", 1) + `,`,
		`ProfileCommitment:` + fmt.Sprintf("%v", this.ProfileCommitment) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedEntryUpdate) String() string {
	if this == nil {
		return "nil"
	}
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%v: %v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	s := strings.Join([]string{`&SignedEntryUpdate{`,
		`NewEntry:` + strings.Replace(strings.Replace(this.NewEntry.String(), "Entry", "Entry", 1), `&`, ``, 1) + `,`,
		`Signatures:` + mapStringForSignatures + `,`,
		`}`,
	}, "")
	return s
}
func (this *Profile) String() string {
	if this == nil {
		return "nil"
	}
	keysForKeys := make([]string, 0, len(this.Keys))
	for k, _ := range this.Keys {
		keysForKeys = append(keysForKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Strings(keysForKeys)
	mapStringForKeys := "map[string][]byte{"
	for _, k := range keysForKeys {
		mapStringForKeys += fmt.Sprintf("%v: %v,", k, this.Keys[k])
	}
	mapStringForKeys += "}"
	s := strings.Join([]string{`&Profile{`,
		`Nonce:` + fmt.Sprintf("%v", this.Nonce) + `,`,
		`Keys:` + mapStringForKeys + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedEpochHead) String() string {
	if this == nil {
		return "nil"
	}
	keysForSignatures := make([]uint64, 0, len(this.Signatures))
	for k, _ := range this.Signatures {
		keysForSignatures = append(keysForSignatures, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForSignatures)
	mapStringForSignatures := "map[uint64][]byte{"
	for _, k := range keysForSignatures {
		mapStringForSignatures += fmt.Sprintf("%v: %v,", k, this.Signatures[k])
	}
	mapStringForSignatures += "}"
	s := strings.Join([]string{`&SignedEpochHead{`,
		`Head:` + strings.Replace(strings.Replace(this.Head.String(), "TimestampedEpochHead", "TimestampedEpochHead", 1), `&`, ``, 1) + `,`,
		`Signatures:` + mapStringForSignatures + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimestampedEpochHead) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TimestampedEpochHead{`,
		`Head:` + strings.Replace(strings.Replace(this.Head.String(), "EpochHead", "EpochHead", 1), `&`, ``, 1) + `,`,
		`Timestamp:` + strings.Replace(strings.Replace(this.Timestamp.String(), "Timestamp", "Timestamp", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EpochHead) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EpochHead{`,
		`Realm:` + fmt.Sprintf("%v", this.Realm) + `,`,
		`Epoch:` + fmt.Sprintf("%v", this.Epoch) + `,`,
		`RootHash:` + fmt.Sprintf("%v", this.RootHash) + `,`,
		`IssueTime:` + strings.Replace(strings.Replace(this.IssueTime.String(), "Timestamp", "Timestamp", 1), `&`, ``, 1) + `,`,
		`PreviousSummaryHash:` + fmt.Sprintf("%v", this.PreviousSummaryHash) + `,`,
		`NextEpochPolicy:` + strings.Replace(strings.Replace(this.NextEpochPolicy.String(), "AuthorizationPolicy", "AuthorizationPolicy", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthorizationPolicy) String() string {
	if this == nil {
		return "nil"
	}
	keysForPublicKeys := make([]uint64, 0, len(this.PublicKeys))
	for k, _ := range this.PublicKeys {
		keysForPublicKeys = append(keysForPublicKeys, k)
	}
	github_com_andres_erbsen_protobuf_sortkeys.Uint64s(keysForPublicKeys)
	mapStringForPublicKeys := "map[uint64]*PublicKey{"
	for _, k := range keysForPublicKeys {
		mapStringForPublicKeys += fmt.Sprintf("%v: %v,", k, this.PublicKeys[k])
	}
	mapStringForPublicKeys += "}"
	s := strings.Join([]string{`&AuthorizationPolicy{`,
		`PublicKeys:` + mapStringForPublicKeys + `,`,
		`Quorum:` + strings.Replace(fmt.Sprintf("%v", this.Quorum), "QuorumExpr", "QuorumExpr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PublicKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PublicKey{`,
		`Ed25519:` + fmt.Sprintf("%v", this.Ed25519) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QuorumExpr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QuorumExpr{`,
		`Threshold:` + fmt.Sprintf("%v", this.Threshold) + `,`,
		`Candidates:` + fmt.Sprintf("%v", this.Candidates) + `,`,
		`Subexpressions:` + strings.Replace(fmt.Sprintf("%v", this.Subexpressions), "QuorumExpr", "QuorumExpr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringClient(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
